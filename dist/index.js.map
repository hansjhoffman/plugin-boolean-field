{
  "version": 3,
  "sources": ["../.spago/prelude/v6.0.1/src/Control/Semigroupoid.purs", "../.spago/prelude/v6.0.1/src/Control/Category.purs", "../.spago/prelude/v6.0.1/src/Data/Boolean.purs", "../.spago/prelude/v6.0.1/src/Data/Function.purs", "../output/Data.Unit/foreign.js", "../.spago/prelude/v6.0.1/src/Data/Functor.purs", "../.spago/control/v6.0.0/src/Control/Alt.purs", "../.spago/prelude/v6.0.1/src/Control/Apply.purs", "../.spago/prelude/v6.0.1/src/Control/Applicative.purs", "../output/Data.Bounded/foreign.js", "../output/Data.Ord/foreign.js", "../output/Data.Eq/foreign.js", "../.spago/prelude/v6.0.1/src/Data/Eq.purs", "../.spago/prelude/v6.0.1/src/Data/Ordering.purs", "../output/Data.Ring/foreign.js", "../output/Data.Semiring/foreign.js", "../.spago/prelude/v6.0.1/src/Data/Semiring.purs", "../.spago/prelude/v6.0.1/src/Data/Ring.purs", "../.spago/prelude/v6.0.1/src/Data/Ord.purs", "../.spago/prelude/v6.0.1/src/Data/Bounded.purs", "../output/Data.Show/foreign.js", "../.spago/prelude/v6.0.1/src/Data/Show.purs", "../.spago/maybe/v6.0.0/src/Data/Maybe.purs", "../.spago/either/v6.1.0/src/Data/Either.purs", "../.spago/control/v6.0.0/src/Control/Lazy.purs", "../output/Data.EuclideanRing/foreign.js", "../.spago/prelude/v6.0.1/src/Data/CommutativeRing.purs", "../.spago/prelude/v6.0.1/src/Data/EuclideanRing.purs", "../.spago/tuples/v7.0.0/src/Data/Tuple.purs", "../.spago/bifunctors/v6.0.0/src/Data/Bifunctor.purs", "../output/Data.String.Common/foreign.js", "../.spago/strings/v6.0.1/src/Data/String/Common.purs", "../.spago/prelude/v6.0.1/src/Control/Bind.purs", "../.spago/transformers/v6.0.0/src/Control/Monad/Error/Class.purs", "../.spago/identity/v6.0.0/src/Data/Identity.purs", "../.spago/tailrec/v6.1.0/src/Control/Monad/Rec/Class.purs", "../output/Data.Lazy/foreign.js", "../output/Unsafe.Coerce/foreign.js", "../.spago/safe-coerce/v2.0.0/src/Safe/Coerce.purs", "../.spago/newtype/v5.0.0/src/Data/Newtype.purs", "../output/Data.Traversable/foreign.js", "../.spago/parsing/v10.2.0/src/Parsing.purs", "../.spago/parsing/v10.2.0/src/Parsing/Combinators.purs", "../output/Data.Array/foreign.js", "../output/Data.Array.ST/foreign.js", "../.spago/arrays/v7.2.0/src/Data/Array.purs", "../output/Data.Array.NonEmpty.Internal/foreign.js", "../output/Data.Enum/foreign.js", "../.spago/enums/v6.0.1/src/Data/Enum.purs", "../output/Data.Function.Uncurried/foreign.js", "../output/Data.String.CodePoints/foreign.js", "../output/Data.String.CodeUnits/foreign.js", "../output/Data.String.Unsafe/foreign.js", "../.spago/strings/v6.0.1/src/Data/String/CodeUnits.purs", "../.spago/strings/v6.0.1/src/Data/String/CodePoints.purs", "../.spago/parsing/v10.2.0/src/Parsing/String.purs", "../.spago/parsing/v10.2.0/src/Parsing/String/Basic.purs", "../src/Main.purs"],
  "sourcesContent": ["module Control.Semigroupoid where\n\n-- | A `Semigroupoid` is similar to a [`Category`](#category) but does not\n-- | require an identity element `identity`, just composable morphisms.\n-- |\n-- | `Semigroupoid`s must satisfy the following law:\n-- |\n-- | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n-- |\n-- | One example of a `Semigroupoid` is the function type constructor `(->)`,\n-- | with `(<<<)` defined as function composition.\nclass Semigroupoid :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a where\n  compose :: forall b c d. a c d -> a b c -> a b d\n\ninstance semigroupoidFn :: Semigroupoid (->) where\n  compose f g x = f (g x)\n\ninfixr 9 compose as <<<\n\n-- | Forwards composition, or `compose` with its arguments reversed.\ncomposeFlipped :: forall a b c d. Semigroupoid a => a b c -> a c d -> a b d\ncomposeFlipped f g = compose g f\n\ninfixr 9 composeFlipped as >>>\n", "module Control.Category\n  ( class Category\n  , identity\n  , module Control.Semigroupoid\n  ) where\n\nimport Control.Semigroupoid (class Semigroupoid, compose, (<<<), (>>>))\n\n-- | `Category`s consist of objects and composable morphisms between them, and\n-- | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\n-- | must have an identity element.\n-- |\n-- | Instances must satisfy the following law in addition to the\n-- | `Semigroupoid` law:\n-- |\n-- | - Identity: `identity <<< p = p <<< identity = p`\nclass Category :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a <= Category a where\n  identity :: forall t. a t t\n\ninstance categoryFn :: Category (->) where\n  identity x = x\n", "module Data.Boolean where\n\n-- | An alias for `true`, which can be useful in guard clauses:\n-- |\n-- | ```purescript\n-- | max x y | x >= y    = x\n-- |         | otherwise = y\n-- | ```\notherwise :: Boolean\notherwise = true\n", "module Data.Function\n  ( flip\n  , const\n  , apply\n  , ($)\n  , applyFlipped\n  , (#)\n  , applyN\n  , on\n  , module Control.Category\n  ) where\n\nimport Control.Category (identity, compose, (<<<), (>>>))\nimport Data.Boolean (otherwise)\nimport Data.Ord ((<=))\nimport Data.Ring ((-))\n\n-- | Given a function that takes two arguments, applies the arguments\n-- | to the function in a swapped order.\n-- |\n-- | ```purescript\n-- | flip append \"1\" \"2\" == append \"2\" \"1\" == \"21\"\n-- |\n-- | const 1 \"two\" == 1\n-- |\n-- | flip const 1 \"two\" == const \"two\" 1 == \"two\"\n-- | ```\nflip :: forall a b c. (a -> b -> c) -> b -> a -> c\nflip f b a = f a b\n\n-- | Returns its first argument and ignores its second.\n-- |\n-- | ```purescript\n-- | const 1 \"hello\" = 1\n-- | ```\n-- |\n-- | It can also be thought of as creating a function that ignores its argument:\n-- |\n-- | ```purescript\n-- | const 1 = \\_ -> 1\n-- | ```\nconst :: forall a b. a -> b -> a\nconst a _ = a\n\n-- | Applies a function to an argument. This is primarily used as the operator\n-- | `($)` which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a chain of composed functions to a value.\napply :: forall a b. (a -> b) -> a -> b\napply f x = f x\n\n-- | Applies a function to an argument: the reverse of `(#)`.\n-- |\n-- | ```purescript\n-- | length $ groupBy productCategory $ filter isInStock $ products\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying chain of composed functions to\n-- | a value:\n-- |\n-- | ```purescript\n-- | length <<< groupBy productCategory <<< filter isInStock $ products\n-- | ```\ninfixr 0 apply as $\n\n-- | Applies an argument to a function. This is primarily used as the `(#)`\n-- | operator, which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a value to a chain of composed functions.\napplyFlipped :: forall a b. a -> (a -> b) -> b\napplyFlipped x f = f x\n\n-- | Applies an argument to a function: the reverse of `($)`.\n-- |\n-- | ```purescript\n-- | products # filter isInStock # groupBy productCategory # length\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying a value to a chain of composed\n-- | functions:\n-- |\n-- | ```purescript\n-- | products # filter isInStock >>> groupBy productCategory >>> length\n-- | ```\ninfixl 1 applyFlipped as #\n\n-- | `applyN f n` applies the function `f` to its argument `n` times.\n-- |\n-- | If n is less than or equal to 0, the function is not applied.\n-- |\n-- | ```purescript\n-- | applyN (_ + 1) 10 0 == 10\n-- | ```\napplyN :: forall a. (a -> a) -> Int -> a -> a\napplyN f = go\n  where\n  go n acc\n    | n <= 0 = acc\n    | otherwise = go (n - 1) (f acc)\n\n-- | The `on` function is used to change the domain of a binary operator.\n-- |\n-- | For example, we can create a function which compares two records based on the values of their `x` properties:\n-- |\n-- | ```purescript\n-- | compareX :: forall r. { x :: Number | r } -> { x :: Number | r } -> Ordering\n-- | compareX = compare `on` _.x\n-- | ```\non :: forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c\non f g x y = g x `f` g y\n", "export const unit = undefined;\n", "module Data.Functor\n  ( class Functor\n  , map\n  , (<$>)\n  , mapFlipped\n  , (<#>)\n  , void\n  , voidRight\n  , (<$)\n  , voidLeft\n  , ($>)\n  , flap\n  , (<@>)\n  ) where\n\nimport Data.Function (const, compose)\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Functor` is a type constructor which supports a mapping operation\n-- | `map`.\n-- |\n-- | `map` can be used to turn functions `a -> b` into functions\n-- | `f a -> f b` whose argument and return types use the type constructor `f`\n-- | to represent some computational context.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Identity: `map identity = identity`\n-- | - Composition: `map (f <<< g) = map f <<< map g`\nclass Functor f where\n  map :: forall a b. (a -> b) -> f a -> f b\n\ninfixl 4 map as <$>\n\n-- | `mapFlipped` is `map` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | [1, 2, 3] <#> \\n -> n * n\n-- | ```\nmapFlipped :: forall f a b. Functor f => f a -> (a -> b) -> f b\nmapFlipped fa f = f <$> fa\n\ninfixl 1 mapFlipped as <#>\n\ninstance functorFn :: Functor ((->) r) where\n  map = compose\n\ninstance functorArray :: Functor Array where\n  map = arrayMap\n\ninstance functorProxy :: Functor Proxy where\n  map _ _ = Proxy\n\nforeign import arrayMap :: forall a b. (a -> b) -> Array a -> Array b\n\n-- | The `void` function is used to ignore the type wrapped by a\n-- | [`Functor`](#functor), replacing it with `Unit` and keeping only the type\n-- | information provided by the type constructor itself.\n-- |\n-- | `void` is often useful when using `do` notation to change the return type\n-- | of a monadic computation:\n-- |\n-- | ```purescript\n-- | main = forE 1 10 \\n -> void do\n-- |   print n\n-- |   print (n * n)\n-- | ```\nvoid :: forall f a. Functor f => f a -> f Unit\nvoid = map (const unit)\n\n-- | Ignore the return value of a computation, using the specified return value\n-- | instead.\nvoidRight :: forall f a b. Functor f => a -> f b -> f a\nvoidRight x = map (const x)\n\ninfixl 4 voidRight as <$\n\n-- | A version of `voidRight` with its arguments flipped.\nvoidLeft :: forall f a b. Functor f => f a -> b -> f b\nvoidLeft f x = const x <$> f\n\ninfixl 4 voidLeft as $>\n\n-- | Apply a value in a computational context to a value in no context.\n-- |\n-- | Generalizes `flip`.\n-- |\n-- | ```purescript\n-- | longEnough :: String -> Bool\n-- | hasSymbol :: String -> Bool\n-- | hasDigit :: String -> Bool\n-- | password :: String\n-- |\n-- | validate :: String -> Array Bool\n-- | validate = flap [longEnough, hasSymbol, hasDigit]\n-- | ```\n-- |\n-- | ```purescript\n-- | flap (-) 3 4 == 1\n-- | threeve <$> Just 1 <@> 'a' <*> Just true == Just (threeve 1 'a' true)\n-- | ```\nflap :: forall f a b. Functor f => f (a -> b) -> a -> f b\nflap ff x = map (\\f -> f x) ff\n\ninfixl 4 flap as <@>\n", "module Control.Alt\n  ( class Alt, alt, (<|>)\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Semigroup (append)\n\n-- | The `Alt` type class identifies an associative operation on a type\n-- | constructor.  It is similar to `Semigroup`, except that it applies to\n-- | types of kind `* -> *`, like `Array` or `List`, rather than concrete types\n-- | `String` or `Number`.\n-- |\n-- | `Alt` instances are required to satisfy the following laws:\n-- |\n-- | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`\n-- | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`\n-- |\n-- | For example, the `Array` (`[]`) type is an instance of `Alt`, where\n-- | `(<|>)` is defined to be concatenation.\n-- |\n-- | A common use case is to select the first \"valid\" item, or, if all items\n-- | are \"invalid\", the last \"invalid\" item.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Control.Alt ((<|>))\n-- | import Data.Maybe (Maybe(..)\n-- | import Data.Either (Either(..))\n-- |\n-- | Nothing <|> Just 1 <|> Just 2 == Just 1\n-- | Left \"err\" <|> Right 1 <|> Right 2 == Right 1\n-- | Left \"err 1\" <|> Left \"err 2\" <|> Left \"err 3\" == Left \"err 3\"\n-- | ```\nclass Functor f <= Alt f where\n  alt :: forall a. f a -> f a -> f a\n\ninfixr 3 alt as <|>\n\ninstance altArray :: Alt Array where\n  alt = append\n", "module Control.Apply\n  ( class Apply\n  , apply\n  , (<*>)\n  , applyFirst\n  , (<*)\n  , applySecond\n  , (*>)\n  , lift2\n  , lift3\n  , lift4\n  , lift5\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Function (const)\nimport Control.Category (identity)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Apply` class provides the `(<*>)` which is used to apply a function\n-- | to an argument under a type constructor.\n-- |\n-- | `Apply` can be used to lift functions of two or more arguments to work on\n-- | values wrapped with the type constructor `f`. It might also be understood\n-- | in terms of the `lift2` function:\n-- |\n-- | ```purescript\n-- | lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n-- | lift2 f a b = f <$> a <*> b\n-- | ```\n-- |\n-- | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts\n-- | the function application operator `($)` to arguments wrapped with the\n-- | type constructor `f`.\n-- |\n-- | Put differently...\n-- | ```\n-- | foo =\n-- |   functionTakingNArguments <$> computationProducingArg1\n-- |                            <*> computationProducingArg2\n-- |                            <*> ...\n-- |                            <*> computationProducingArgN\n-- | ```\n-- |\n-- | Instances must satisfy the following law in addition to the `Functor`\n-- | laws:\n-- |\n-- | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`\n-- |\n-- | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\nclass Functor f <= Apply f where\n  apply :: forall a b. f (a -> b) -> f a -> f b\n\ninfixl 4 apply as <*>\n\ninstance applyFn :: Apply ((->) r) where\n  apply f g x = f x (g x)\n\ninstance applyArray :: Apply Array where\n  apply = arrayApply\n\nforeign import arrayApply :: forall a b. Array (a -> b) -> Array a -> Array b\n\ninstance applyProxy :: Apply Proxy where\n  apply _ _ = Proxy\n\n-- | Combine two effectful actions, keeping only the result of the first.\napplyFirst :: forall a b f. Apply f => f a -> f b -> f a\napplyFirst a b = const <$> a <*> b\n\ninfixl 4 applyFirst as <*\n\n-- | Combine two effectful actions, keeping only the result of the second.\napplySecond :: forall a b f. Apply f => f a -> f b -> f b\napplySecond a b = const identity <$> a <*> b\n\ninfixl 4 applySecond as *>\n\n-- | Lift a function of two arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\n-- |\n-- | ```purescript\n-- | lift2 add (Just 1) (Just 2) == Just 3\n-- | lift2 add Nothing (Just 2) == Nothing\n-- |```\n-- |\nlift2 :: forall a b c f. Apply f => (a -> b -> c) -> f a -> f b -> f c\nlift2 f a b = f <$> a <*> b\n\n-- | Lift a function of three arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift3 :: forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nlift3 f a b c = f <$> a <*> b <*> c\n\n-- | Lift a function of four arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift4 :: forall a b c d e f. Apply f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e\nlift4 f a b c d = f <$> a <*> b <*> c <*> d\n\n-- | Lift a function of five arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift5 :: forall a b c d e f g. Apply f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g\nlift5 f a b c d e = f <$> a <*> b <*> c <*> d <*> e\n", "module Control.Applicative\n  ( class Applicative\n  , pure\n  , liftA1\n  , unless\n  , when\n  , module Control.Apply\n  , module Data.Functor\n  ) where\n\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Applicative` type class extends the [`Apply`](#apply) type class\n-- | with a `pure` function, which can be used to create values of type `f a`\n-- | from values of type `a`.\n-- |\n-- | Where [`Apply`](#apply) provides the ability to lift functions of two or\n-- | more arguments to functions whose arguments are wrapped using `f`, and\n-- | [`Functor`](#functor) provides the ability to lift functions of one\n-- | argument, `pure` can be seen as the function which lifts functions of\n-- | _zero_ arguments. That is, `Applicative` functors support a lifting\n-- | operation for any number of function arguments.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Identity: `(pure identity) <*> v = v`\n-- | - Composition: `pure (<<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n-- | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n-- | - Interchange: `u <*> (pure y) = (pure (_ $ y)) <*> u`\nclass Apply f <= Applicative f where\n  pure :: forall a. a -> f a\n\ninstance applicativeFn :: Applicative ((->) r) where\n  pure x _ = x\n\ninstance applicativeArray :: Applicative Array where\n  pure x = [ x ]\n\ninstance applicativeProxy :: Applicative Proxy where\n  pure _ = Proxy\n\n-- | `liftA1` provides a default implementation of `(<$>)` for any\n-- | [`Applicative`](#applicative) functor, without using `(<$>)` as provided\n-- | by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\n-- | relationship.\n-- |\n-- | `liftA1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftA1\n-- | ```\nliftA1 :: forall f a b. Applicative f => (a -> b) -> f a -> f b\nliftA1 f a = pure f <*> a\n\n-- | Perform an applicative action when a condition is true.\nwhen :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nwhen true m = m\nwhen false _ = pure unit\n\n-- | Perform an applicative action unless a condition is true.\nunless :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nunless false m = m\nunless true _ = pure unit\n", "export const topInt = 2147483647;\nexport const bottomInt = -2147483648;\n\nexport const topChar = String.fromCharCode(65535);\nexport const bottomChar = String.fromCharCode(0);\n\nexport const topNumber = Number.POSITIVE_INFINITY;\nexport const bottomNumber = Number.NEGATIVE_INFINITY;\n", "var unsafeCompareImpl = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (x) {\n        return function (y) {\n          return x < y ? lt : x === y ? eq : gt;\n        };\n      };\n    };\n  };\n};\n\nexport const ordBooleanImpl = unsafeCompareImpl;\nexport const ordIntImpl = unsafeCompareImpl;\nexport const ordNumberImpl = unsafeCompareImpl;\nexport const ordStringImpl = unsafeCompareImpl;\nexport const ordCharImpl = unsafeCompareImpl;\n\nexport const ordArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var i = 0;\n      var xlen = xs.length;\n      var ylen = ys.length;\n      while (i < xlen && i < ylen) {\n        var x = xs[i];\n        var y = ys[i];\n        var o = f(x)(y);\n        if (o !== 0) {\n          return o;\n        }\n        i++;\n      }\n      if (xlen === ylen) {\n        return 0;\n      } else if (xlen > ylen) {\n        return -1;\n      } else {\n        return 1;\n      }\n    };\n  };\n};\n", "var refEq = function (r1) {\n  return function (r2) {\n    return r1 === r2;\n  };\n};\n\nexport const eqBooleanImpl = refEq;\nexport const eqIntImpl = refEq;\nexport const eqNumberImpl = refEq;\nexport const eqCharImpl = refEq;\nexport const eqStringImpl = refEq;\n\nexport const eqArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      if (xs.length !== ys.length) return false;\n      for (var i = 0; i < xs.length; i++) {\n        if (!f(xs[i])(ys[i])) return false;\n      }\n      return true;\n    };\n  };\n};\n", "module Data.Eq\n  ( class Eq\n  , eq\n  , (==)\n  , notEq\n  , (/=)\n  , class Eq1\n  , eq1\n  , notEq1\n  , class EqRecord\n  , eqRecord\n  ) where\n\nimport Data.HeytingAlgebra ((&&))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Eq` type class represents types which support decidable equality.\n-- |\n-- | `Eq` instances should satisfy the following laws:\n-- |\n-- | - Reflexivity: `x == x = true`\n-- | - Symmetry: `x == y = y == x`\n-- | - Transitivity: if `x == y` and `y == z` then `x == z`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN /= NaN`. Additionally,\n-- | computing with `Number` can result in a loss of precision, so sometimes\n-- | values that should be equivalent are not.\nclass Eq a where\n  eq :: a -> a -> Boolean\n\ninfix 4 eq as ==\n\n-- | `notEq` tests whether one value is _not equal_ to another. Shorthand for\n-- | `not (eq x y)`.\nnotEq :: forall a. Eq a => a -> a -> Boolean\nnotEq x y = (x == y) == false\n\ninfix 4 notEq as /=\n\ninstance eqBoolean :: Eq Boolean where\n  eq = eqBooleanImpl\n\ninstance eqInt :: Eq Int where\n  eq = eqIntImpl\n\ninstance eqNumber :: Eq Number where\n  eq = eqNumberImpl\n\ninstance eqChar :: Eq Char where\n  eq = eqCharImpl\n\ninstance eqString :: Eq String where\n  eq = eqStringImpl\n\ninstance eqUnit :: Eq Unit where\n  eq _ _ = true\n\ninstance eqVoid :: Eq Void where\n  eq _ _ = true\n\ninstance eqArray :: Eq a => Eq (Array a) where\n  eq = eqArrayImpl eq\n\ninstance eqRec :: (RL.RowToList row list, EqRecord list row) => Eq (Record row) where\n  eq = eqRecord (Proxy :: Proxy list)\n\ninstance eqProxy :: Eq (Proxy a) where\n  eq _ _ = true\n\nforeign import eqBooleanImpl :: Boolean -> Boolean -> Boolean\nforeign import eqIntImpl :: Int -> Int -> Boolean\nforeign import eqNumberImpl :: Number -> Number -> Boolean\nforeign import eqCharImpl :: Char -> Char -> Boolean\nforeign import eqStringImpl :: String -> String -> Boolean\n\nforeign import eqArrayImpl :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Boolean\n\n-- | The `Eq1` type class represents type constructors with decidable equality.\nclass Eq1 f where\n  eq1 :: forall a. Eq a => f a -> f a -> Boolean\n\ninstance eq1Array :: Eq1 Array where\n  eq1 = eq\n\nnotEq1 :: forall f a. Eq1 f => Eq a => f a -> f a -> Boolean\nnotEq1 x y = (x `eq1` y) == false\n\n-- | A class for records where all fields have `Eq` instances, used to implement\n-- | the `Eq` instance for records.\nclass EqRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row where\n  eqRecord :: Proxy rowlist -> Record row -> Record row -> Boolean\n\ninstance eqRowNil :: EqRecord RL.Nil row where\n  eqRecord _ _ _ = true\n\ninstance eqRowCons ::\n  ( EqRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Eq focus\n  ) =>\n  EqRecord (RL.Cons key focus rowlistTail) row where\n  eqRecord _ ra rb = (get ra == get rb) && tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = eqRecord (Proxy :: Proxy rowlistTail) ra rb\n", "module Data.Ordering (Ordering(..), invert) where\n\nimport Data.Eq (class Eq)\nimport Data.Semigroup (class Semigroup)\nimport Data.Show (class Show)\n\n-- | The `Ordering` data type represents the three possible outcomes of\n-- | comparing two values:\n-- |\n-- | `LT` - The first value is _less than_ the second.\n-- | `GT` - The first value is _greater than_ the second.\n-- | `EQ` - The first value is _equal to_ the second.\ndata Ordering = LT | GT | EQ\n\ninstance eqOrdering :: Eq Ordering where\n  eq LT LT = true\n  eq GT GT = true\n  eq EQ EQ = true\n  eq _ _ = false\n\ninstance semigroupOrdering :: Semigroup Ordering where\n  append LT _ = LT\n  append GT _ = GT\n  append EQ y = y\n\ninstance showOrdering :: Show Ordering where\n  show LT = \"LT\"\n  show GT = \"GT\"\n  show EQ = \"EQ\"\n\n-- | Reverses an `Ordering` value, flipping greater than for less than while\n-- | preserving equality.\ninvert :: Ordering -> Ordering\ninvert GT = LT\ninvert EQ = EQ\ninvert LT = GT\n", "export const intSub = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x - y | 0;\n  };\n};\n\nexport const numSub = function (n1) {\n  return function (n2) {\n    return n1 - n2;\n  };\n};\n", "export const intAdd = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x + y | 0;\n  };\n};\n\nexport const intMul = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x * y | 0;\n  };\n};\n\nexport const numAdd = function (n1) {\n  return function (n2) {\n    return n1 + n2;\n  };\n};\n\nexport const numMul = function (n1) {\n  return function (n2) {\n    return n1 * n2;\n  };\n};\n", "module Data.Semiring\n  ( class Semiring\n  , add\n  , (+)\n  , zero\n  , mul\n  , (*)\n  , one\n  , class SemiringRecord\n  , addRecord\n  , mulRecord\n  , oneRecord\n  , zeroRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semiring` class is for types that support an addition and\n-- | multiplication operation.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Commutative monoid under addition:\n-- |   - Associativity: `(a + b) + c = a + (b + c)`\n-- |   - Identity: `zero + a = a + zero = a`\n-- |   - Commutative: `a + b = b + a`\n-- | - Monoid under multiplication:\n-- |   - Associativity: `(a * b) * c = a * (b * c)`\n-- |   - Identity: `one * a = a * one = a`\n-- | - Multiplication distributes over addition:\n-- |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`\n-- |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`\n-- | - Annihilation: `zero * a = a * zero = zero`\n-- |\n-- | **Note:** The `Number` and `Int` types are not fully law abiding\n-- | members of this class hierarchy due to the potential for arithmetic\n-- | overflows, and in the case of `Number`, the presence of `NaN` and\n-- | `Infinity` values. The behaviour is unspecified in these cases.\nclass Semiring a where\n  add :: a -> a -> a\n  zero :: a\n  mul :: a -> a -> a\n  one :: a\n\ninfixl 6 add as +\ninfixl 7 mul as *\n\ninstance semiringInt :: Semiring Int where\n  add = intAdd\n  zero = 0\n  mul = intMul\n  one = 1\n\ninstance semiringNumber :: Semiring Number where\n  add = numAdd\n  zero = 0.0\n  mul = numMul\n  one = 1.0\n\ninstance semiringFn :: Semiring b => Semiring (a -> b) where\n  add f g x = f x + g x\n  zero = \\_ -> zero\n  mul f g x = f x * g x\n  one = \\_ -> one\n\ninstance semiringUnit :: Semiring Unit where\n  add _ _ = unit\n  zero = unit\n  mul _ _ = unit\n  one = unit\n\ninstance semiringProxy :: Semiring (Proxy a) where\n  add _ _ = Proxy\n  mul _ _ = Proxy\n  one = Proxy\n  zero = Proxy\n\ninstance semiringRecord :: (RL.RowToList row list, SemiringRecord list row row) => Semiring (Record row) where\n  add = addRecord (Proxy :: Proxy list)\n  mul = mulRecord (Proxy :: Proxy list)\n  one = oneRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  zero = zeroRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n\nforeign import intAdd :: Int -> Int -> Int\nforeign import intMul :: Int -> Int -> Int\nforeign import numAdd :: Number -> Number -> Number\nforeign import numMul :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Semiring` instances, used to\n-- | implement the `Semiring` instance for records.\nclass SemiringRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemiringRecord rowlist row subrow | rowlist -> subrow where\n  addRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  mulRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  oneRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  zeroRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance semiringRecordNil :: SemiringRecord RL.Nil row () where\n  addRecord _ _ _ = {}\n  mulRecord _ _ _ = {}\n  oneRecord _ _ = {}\n  zeroRecord _ _ = {}\n\ninstance semiringRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemiringRecord rowlistTail row subrowTail\n  , Semiring focus\n  ) =>\n  SemiringRecord (RL.Cons key focus rowlistTail) row subrow where\n  addRecord _ ra rb = insert (get ra + get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = addRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  mulRecord _ ra rb = insert (get ra * get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = mulRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  oneRecord _ _ = insert one tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = oneRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  zeroRecord _ _ = insert zero tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = zeroRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n", "module Data.Ring\n  ( class Ring\n  , sub\n  , negate\n  , (-)\n  , module Data.Semiring\n  , class RingRecord\n  , subRecord\n  ) where\n\nimport Data.Semiring (class Semiring, class SemiringRecord, add, mul, one, zero, (*), (+))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Ring` class is for types that support addition, multiplication,\n-- | and subtraction operations.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Semiring`\n-- | laws:\n-- |\n-- | - Additive inverse: `a - a = zero`\n-- | - Compatibility of `sub` and `negate`: `a - b = a + (zero - b)`\nclass Semiring a <= Ring a where\n  sub :: a -> a -> a\n\ninfixl 6 sub as -\n\ninstance ringInt :: Ring Int where\n  sub = intSub\n\ninstance ringNumber :: Ring Number where\n  sub = numSub\n\ninstance ringUnit :: Ring Unit where\n  sub _ _ = unit\n\ninstance ringFn :: Ring b => Ring (a -> b) where\n  sub f g x = f x - g x\n\ninstance ringProxy :: Ring (Proxy a) where\n  sub _ _ = Proxy\n\ninstance ringRecord :: (RL.RowToList row list, RingRecord list row row) => Ring (Record row) where\n  sub = subRecord (Proxy :: Proxy list)\n\n-- | `negate x` can be used as a shorthand for `zero - x`.\nnegate :: forall a. Ring a => a -> a\nnegate a = zero - a\n\nforeign import intSub :: Int -> Int -> Int\nforeign import numSub :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Ring` instances, used to\n-- | implement the `Ring` instance for records.\nclass RingRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemiringRecord rowlist row subrow <= RingRecord rowlist row subrow | rowlist -> subrow where\n  subRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance ringRecordNil :: RingRecord RL.Nil row () where\n  subRecord _ _ _ = {}\n\ninstance ringRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , RingRecord rowlistTail row subrowTail\n  , Ring focus\n  ) =>\n  RingRecord (RL.Cons key focus rowlistTail) row subrow where\n  subRecord _ ra rb = insert (get ra - get rb) tail\n    where\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = subRecord (Proxy :: Proxy rowlistTail) ra rb\n", "module Data.Ord\n  ( class Ord\n  , compare\n  , class Ord1\n  , compare1\n  , lessThan\n  , (<)\n  , lessThanOrEq\n  , (<=)\n  , greaterThan\n  , (>)\n  , greaterThanOrEq\n  , (>=)\n  , comparing\n  , min\n  , max\n  , clamp\n  , between\n  , abs\n  , signum\n  , module Data.Ordering\n  , class OrdRecord\n  , compareRecord\n  ) where\n\nimport Data.Eq (class Eq, class Eq1, class EqRecord, (/=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Ordering (Ordering(..))\nimport Data.Ring (class Ring, zero, one, negate)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Ord` type class represents types which support comparisons with a\n-- | _total order_.\n-- |\n-- | `Ord` instances should satisfy the laws of total orderings:\n-- |\n-- | - Reflexivity: `a <= a`\n-- | - Antisymmetry: if `a <= b` and `b <= a` then `a == b`\n-- | - Transitivity: if `a <= b` and `b <= c` then `a <= c`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN <= NaN` evaluates to `false`\nclass Eq a <= Ord a where\n  compare :: a -> a -> Ordering\n\ninstance ordBoolean :: Ord Boolean where\n  compare = ordBooleanImpl LT EQ GT\n\ninstance ordInt :: Ord Int where\n  compare = ordIntImpl LT EQ GT\n\ninstance ordNumber :: Ord Number where\n  compare = ordNumberImpl LT EQ GT\n\ninstance ordString :: Ord String where\n  compare = ordStringImpl LT EQ GT\n\ninstance ordChar :: Ord Char where\n  compare = ordCharImpl LT EQ GT\n\ninstance ordUnit :: Ord Unit where\n  compare _ _ = EQ\n\ninstance ordVoid :: Ord Void where\n  compare _ _ = EQ\n\ninstance ordProxy :: Ord (Proxy a) where\n  compare _ _ = EQ\n\ninstance ordArray :: Ord a => Ord (Array a) where\n  compare = \\xs ys -> compare 0 (ordArrayImpl toDelta xs ys)\n    where\n    toDelta x y =\n      case compare x y of\n        EQ -> 0\n        LT -> 1\n        GT -> -1\n\nforeign import ordBooleanImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Boolean\n  -> Boolean\n  -> Ordering\n\nforeign import ordIntImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Int\n  -> Int\n  -> Ordering\n\nforeign import ordNumberImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Number\n  -> Number\n  -> Ordering\n\nforeign import ordStringImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> String\n  -> String\n  -> Ordering\n\nforeign import ordCharImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Char\n  -> Char\n  -> Ordering\n\nforeign import ordArrayImpl :: forall a. (a -> a -> Int) -> Array a -> Array a -> Int\n\ninstance ordOrdering :: Ord Ordering where\n  compare LT LT = EQ\n  compare EQ EQ = EQ\n  compare GT GT = EQ\n  compare LT _ = LT\n  compare EQ LT = GT\n  compare EQ GT = LT\n  compare GT _ = GT\n\n-- | Test whether one value is _strictly less than_ another.\nlessThan :: forall a. Ord a => a -> a -> Boolean\nlessThan a1 a2 = case a1 `compare` a2 of\n  LT -> true\n  _ -> false\n\n-- | Test whether one value is _strictly greater than_ another.\ngreaterThan :: forall a. Ord a => a -> a -> Boolean\ngreaterThan a1 a2 = case a1 `compare` a2 of\n  GT -> true\n  _ -> false\n\n-- | Test whether one value is _non-strictly less than_ another.\nlessThanOrEq :: forall a. Ord a => a -> a -> Boolean\nlessThanOrEq a1 a2 = case a1 `compare` a2 of\n  GT -> false\n  _ -> true\n\n-- | Test whether one value is _non-strictly greater than_ another.\ngreaterThanOrEq :: forall a. Ord a => a -> a -> Boolean\ngreaterThanOrEq a1 a2 = case a1 `compare` a2 of\n  LT -> false\n  _ -> true\n\ninfixl 4 lessThan as <\ninfixl 4 lessThanOrEq as <=\ninfixl 4 greaterThan as >\ninfixl 4 greaterThanOrEq as >=\n\n-- | Compares two values by mapping them to a type with an `Ord` instance.\ncomparing :: forall a b. Ord b => (a -> b) -> (a -> a -> Ordering)\ncomparing f x y = compare (f x) (f y)\n\n-- | Take the minimum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmin :: forall a. Ord a => a -> a -> a\nmin x y =\n  case compare x y of\n    LT -> x\n    EQ -> x\n    GT -> y\n\n-- | Take the maximum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmax :: forall a. Ord a => a -> a -> a\nmax x y =\n  case compare x y of\n    LT -> y\n    EQ -> x\n    GT -> x\n\n-- | Clamp a value between a minimum and a maximum. For example:\n-- |\n-- | ``` purescript\n-- | let f = clamp 0 10\n-- | f (-5) == 0\n-- | f 5    == 5\n-- | f 15   == 10\n-- | ```\nclamp :: forall a. Ord a => a -> a -> a -> a\nclamp low hi x = min hi (max low x)\n\n-- | Test whether a value is between a minimum and a maximum (inclusive).\n-- | For example:\n-- |\n-- | ``` purescript\n-- | let f = between 0 10\n-- | f 0    == true\n-- | f (-5) == false\n-- | f 5    == true\n-- | f 10   == true\n-- | f 15   == false\n-- | ```\nbetween :: forall a. Ord a => a -> a -> a -> Boolean\nbetween low hi x\n  | x < low = false\n  | x > hi = false\n  | true = true\n\n-- | The absolute value function. `abs x` is defined as `if x >= zero then x\n-- | else negate x`.\nabs :: forall a. Ord a => Ring a => a -> a\nabs x = if x >= zero then x else negate x\n\n-- | The sign function; returns `one` if the argument is positive,\n-- | `negate one` if the argument is negative, or `zero` if the argument is `zero`.\n-- | For floating point numbers with signed zeroes, when called with a zero,\n-- | this function returns the argument in order to preserve the sign.\n-- | For any `x`, we should have `signum x * abs x == x`.\nsignum :: forall a. Ord a => Ring a => a -> a\nsignum x =\n  if x < zero then negate one\n  else if x > zero then one\n  else x\n\n-- | The `Ord1` type class represents totally ordered type constructors.\nclass Eq1 f <= Ord1 f where\n  compare1 :: forall a. Ord a => f a -> f a -> Ordering\n\ninstance ord1Array :: Ord1 Array where\n  compare1 = compare\n\nclass OrdRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row <= OrdRecord rowlist row where\n  compareRecord :: Proxy rowlist -> Record row -> Record row -> Ordering\n\ninstance ordRecordNil :: OrdRecord RL.Nil row where\n  compareRecord _ _ _ = EQ\n\ninstance ordRecordCons ::\n  ( OrdRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Ord focus\n  ) =>\n  OrdRecord (RL.Cons key focus rowlistTail) row where\n  compareRecord _ ra rb =\n    if left /= EQ then left\n    else compareRecord (Proxy :: Proxy rowlistTail) ra rb\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    unsafeGet' = unsafeGet :: String -> Record row -> focus\n    left = unsafeGet' key ra `compare` unsafeGet' key rb\n\ninstance ordRecord ::\n  ( RL.RowToList row list\n  , OrdRecord list row\n  ) =>\n  Ord (Record row) where\n  compare = compareRecord (Proxy :: Proxy list)\n", "module Data.Bounded\n  ( class Bounded\n  , bottom\n  , top\n  , module Data.Ord\n  , class BoundedRecord\n  , bottomRecord\n  , topRecord\n  ) where\n\nimport Data.Ord (class Ord, class OrdRecord, Ordering(..), compare, (<), (<=), (>), (>=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bounded` type class represents totally ordered types that have an\n-- | upper and lower boundary.\n-- |\n-- | Instances should satisfy the following law in addition to the `Ord` laws:\n-- |\n-- | - Bounded: `bottom <= a <= top`\nclass Ord a <= Bounded a where\n  top :: a\n  bottom :: a\n\ninstance boundedBoolean :: Bounded Boolean where\n  top = true\n  bottom = false\n\n-- | The `Bounded` `Int` instance has `top :: Int` equal to 2^31 - 1,\n-- | and `bottom :: Int` equal to -2^31, since these are the largest and smallest\n-- | integers representable by twos-complement 32-bit integers, respectively.\ninstance boundedInt :: Bounded Int where\n  top = topInt\n  bottom = bottomInt\n\nforeign import topInt :: Int\nforeign import bottomInt :: Int\n\n-- | Characters fall within the Unicode range.\ninstance boundedChar :: Bounded Char where\n  top = topChar\n  bottom = bottomChar\n\nforeign import topChar :: Char\nforeign import bottomChar :: Char\n\ninstance boundedOrdering :: Bounded Ordering where\n  top = GT\n  bottom = LT\n\ninstance boundedUnit :: Bounded Unit where\n  top = unit\n  bottom = unit\n\nforeign import topNumber :: Number\nforeign import bottomNumber :: Number\n\ninstance boundedNumber :: Bounded Number where\n  top = topNumber\n  bottom = bottomNumber\n\ninstance boundedProxy :: Bounded (Proxy a) where\n  bottom = Proxy\n  top = Proxy\n\nclass BoundedRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass OrdRecord rowlist row <= BoundedRecord rowlist row subrow | rowlist -> subrow where\n  topRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  bottomRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance boundedRecordNil :: BoundedRecord RL.Nil row () where\n  topRecord _ _ = {}\n  bottomRecord _ _ = {}\n\ninstance boundedRecordCons ::\n  ( IsSymbol key\n  , Bounded focus\n  , Row.Cons key focus rowTail row\n  , Row.Cons key focus subrowTail subrow\n  , BoundedRecord rowlistTail row subrowTail\n  ) =>\n  BoundedRecord (RL.Cons key focus rowlistTail) row subrow where\n  topRecord _ rowProxy = insert top tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = topRecord (Proxy :: Proxy rowlistTail) rowProxy\n\n  bottomRecord _ rowProxy = insert bottom tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = bottomRecord (Proxy :: Proxy rowlistTail) rowProxy\n\ninstance boundedRecord ::\n  ( RL.RowToList row list\n  , BoundedRecord list row row\n  ) =>\n  Bounded (Record row) where\n  top = topRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  bottom = bottomRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n", "export const showIntImpl = function (n) {\n  return n.toString();\n};\n\nexport const showNumberImpl = function (n) {\n  var str = n.toString();\n  return isNaN(str + \".0\") ? str : str + \".0\";\n};\n\nexport const showCharImpl = function (c) {\n  var code = c.charCodeAt(0);\n  if (code < 0x20 || code === 0x7F) {\n    switch (c) {\n      case \"\\x07\": return \"'\\\\a'\";\n      case \"\\b\": return \"'\\\\b'\";\n      case \"\\f\": return \"'\\\\f'\";\n      case \"\\n\": return \"'\\\\n'\";\n      case \"\\r\": return \"'\\\\r'\";\n      case \"\\t\": return \"'\\\\t'\";\n      case \"\\v\": return \"'\\\\v'\";\n    }\n    return \"'\\\\\" + code.toString(10) + \"'\";\n  }\n  return c === \"'\" || c === \"\\\\\" ? \"'\\\\\" + c + \"'\" : \"'\" + c + \"'\";\n};\n\nexport const showStringImpl = function (s) {\n  var l = s.length;\n  return \"\\\"\" + s.replace(\n    /[\\0-\\x1F\\x7F\"\\\\]/g, // eslint-disable-line no-control-regex\n    function (c, i) {\n      switch (c) {\n        case \"\\\"\":\n        case \"\\\\\":\n          return \"\\\\\" + c;\n        case \"\\x07\": return \"\\\\a\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\f\": return \"\\\\f\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\v\": return \"\\\\v\";\n      }\n      var k = i + 1;\n      var empty = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n      return \"\\\\\" + c.charCodeAt(0).toString(10) + empty;\n    }\n  ) + \"\\\"\";\n};\n\nexport const showArrayImpl = function (f) {\n  return function (xs) {\n    var ss = [];\n    for (var i = 0, l = xs.length; i < l; i++) {\n      ss[i] = f(xs[i]);\n    }\n    return \"[\" + ss.join(\",\") + \"]\";\n  };\n};\n", "module Data.Show\n  ( class Show\n  , show\n  , class ShowRecordFields\n  , showRecordFields\n  ) where\n\nimport Data.Semigroup ((<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row (class Nub)\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Show` type class represents those types which can be converted into\n-- | a human-readable `String` representation.\n-- |\n-- | While not required, it is recommended that for any expression `x`, the\n-- | string `show x` be executable PureScript code which evaluates to the same\n-- | value as the expression `x`.\nclass Show a where\n  show :: a -> String\n\ninstance showUnit :: Show Unit where\n  show _ = \"unit\"\n\ninstance showBoolean :: Show Boolean where\n  show true = \"true\"\n  show false = \"false\"\n\ninstance showInt :: Show Int where\n  show = showIntImpl\n\ninstance showNumber :: Show Number where\n  show = showNumberImpl\n\ninstance showChar :: Show Char where\n  show = showCharImpl\n\ninstance showString :: Show String where\n  show = showStringImpl\n\ninstance showArray :: Show a => Show (Array a) where\n  show = showArrayImpl show\n\ninstance showProxy :: Show (Proxy a) where\n  show _ = \"Proxy\"\n\ninstance showVoid :: Show Void where\n  show = absurd\n\ninstance showRecord ::\n  ( Nub rs rs\n  , RL.RowToList rs ls\n  , ShowRecordFields ls rs\n  ) =>\n  Show (Record rs) where\n  show record = \"{\" <> showRecordFields (Proxy :: Proxy ls) record <> \"}\"\n\n-- | A class for records where all fields have `Show` instances, used to\n-- | implement the `Show` instance for records.\nclass ShowRecordFields :: RL.RowList Type -> Row Type -> Constraint\nclass ShowRecordFields rowlist row where\n  showRecordFields :: Proxy rowlist -> Record row -> String\n\ninstance showRecordFieldsNil :: ShowRecordFields RL.Nil row where\n  showRecordFields _ _ = \"\"\nelse\ninstance showRecordFieldsConsNil ::\n  ( IsSymbol key\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus RL.Nil) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \" \"\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\nelse\ninstance showRecordFieldsCons ::\n  ( IsSymbol key\n  , ShowRecordFields rowlistTail row\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus rowlistTail) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \",\" <> tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\n    tail = showRecordFields (Proxy :: Proxy rowlistTail) record\n\nforeign import showIntImpl :: Int -> String\nforeign import showNumberImpl :: Number -> String\nforeign import showCharImpl :: Char -> String\nforeign import showStringImpl :: String -> String\nforeign import showArrayImpl :: forall a. (a -> String) -> Array a -> String\n", "module Data.Maybe where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Extend (class Extend)\nimport Control.Plus (class Plus)\n\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Ord (class Ord1)\n\n-- | The `Maybe` type is used to represent optional values and can be seen as\n-- | something like a type-safe `null`, where `Nothing` is `null` and `Just x`\n-- | is the non-null value `x`.\ndata Maybe a = Nothing | Just a\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Just` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing == Nothing\n-- | ```\ninstance functorMaybe :: Functor Maybe where\n  map fn (Just x) = Just (fn x)\n  map _  _        = Nothing\n\n-- | The `Apply` instance allows functions contained within a `Just` to\n-- | transform a value contained within a `Just` using the `apply` operator:\n-- |\n-- | ``` purescript\n-- | Just f <*> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Just f <*> Nothing == Nothing\n-- | Nothing <*> Just x == Nothing\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a\n-- | pure function to take `Maybe`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Maybe a -> Maybe b -> Maybe c`:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> Just y == Just (f x y)\n-- | ```\n-- |\n-- | The `Nothing`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Nothing`\n-- | means the whole result becomes `Nothing` also:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing <*> Just y == Nothing\n-- | f <$> Just x <*> Nothing == Nothing\n-- | f <$> Nothing <*> Nothing == Nothing\n-- | ```\ninstance applyMaybe :: Apply Maybe where\n  apply (Just fn) x = fn <$> x\n  apply Nothing   _ = Nothing\n\n-- | The `Applicative` instance enables lifting of values into `Maybe` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Maybe _ == Just x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Maybe` and non-`Maybe` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Maybe` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> pure y == Just (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Just` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Just` with a new constructor.\ninstance applicativeMaybe :: Applicative Maybe where\n  pure = Just\n\n-- | The `Alt` instance allows for a choice to be made between two `Maybe`\n-- | values with the `<|>` operator, where the first `Just` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Just x <|> Just y == Just x\n-- | Nothing <|> Just y == Just y\n-- | Nothing <|> Nothing == Nothing\n-- | ```\ninstance altMaybe :: Alt Maybe where\n  alt Nothing r = r\n  alt l       _ = l\n\n-- | The `Plus` instance provides a default `Maybe` value:\n-- |\n-- | ``` purescript\n-- | empty :: Maybe _ == Nothing\n-- | ```\ninstance plusMaybe :: Plus Maybe where\n  empty = Nothing\n\n-- | The `Alternative` instance guarantees that there are both `Applicative` and\n-- | `Plus` instances for `Maybe`.\ninstance alternativeMaybe :: Alternative Maybe\n\n-- | The `Bind` instance allows sequencing of `Maybe` values and functions that\n-- | return a `Maybe` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Just x >>= f = f x\n-- | Nothing >>= f = Nothing\n-- | ```\ninstance bindMaybe :: Bind Maybe where\n  bind (Just x) k = k x\n  bind Nothing  _ = Nothing\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Maybe`. This also enables the `do` syntactic sugar:\n-- |\n-- | ``` purescript\n-- | do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | case x of\n-- |   Nothing -> Nothing\n-- |   Just x' -> case y of\n-- |     Nothing -> Nothing\n-- |     Just y' -> Just (f x' y')\n-- | ```\ninstance monadMaybe :: Monad Maybe\n\n-- | The `Extend` instance allows sequencing of `Maybe` values and functions\n-- | that accept a `Maybe a` and return a non-`Maybe` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Nothing = Nothing\n-- | f <<= x = Just (f x)\n-- | ```\ninstance extendMaybe :: Extend Maybe where\n  extend _ Nothing  = Nothing\n  extend f x        = Just (f x)\n\ninstance invariantMaybe :: Invariant Maybe where\n  imap = imapF\n\n-- | The `Semigroup` instance enables use of the operator `<>` on `Maybe` values\n-- | whenever there is a `Semigroup` instance for the type the `Maybe` contains.\n-- | The exact behaviour of `<>` depends on the \"inner\" `Semigroup` instance,\n-- | but generally captures the notion of appending or combining things.\n-- |\n-- | ``` purescript\n-- | Just x <> Just y = Just (x <> y)\n-- | Just x <> Nothing = Just x\n-- | Nothing <> Just y = Just y\n-- | Nothing <> Nothing = Nothing\n-- | ```\ninstance semigroupMaybe :: Semigroup a => Semigroup (Maybe a) where\n  append Nothing y = y\n  append x Nothing = x\n  append (Just x) (Just y) = Just (x <> y)\n\ninstance monoidMaybe :: Semigroup a => Monoid (Maybe a) where\n  mempty = Nothing\n\ninstance semiringMaybe :: Semiring a => Semiring (Maybe a) where\n  zero = Nothing\n  one = Just one\n\n  add Nothing y = y\n  add x Nothing = x\n  add (Just x) (Just y) = Just (add x y)\n\n  mul x y = mul <$> x <*> y\n\n-- | The `Eq` instance allows `Maybe` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for the\n-- | type the `Maybe` contains.\nderive instance eqMaybe :: Eq a => Eq (Maybe a)\n\ninstance eq1Maybe :: Eq1 Maybe where eq1 = eq\n\n-- | The `Ord` instance allows `Maybe` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | the type the `Maybe` contains.\n-- |\n-- | `Nothing` is considered to be less than any `Just` value.\nderive instance ordMaybe :: Ord a => Ord (Maybe a)\n\ninstance ord1Maybe :: Ord1 Maybe where compare1 = compare\n\ninstance boundedMaybe :: Bounded a => Bounded (Maybe a) where\n  top = Just top\n  bottom = Nothing\n\n-- | The `Show` instance allows `Maybe` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for the type the `Maybe`\n-- | contains.\ninstance showMaybe :: Show a => Show (Maybe a) where\n  show (Just x) = \"(Just \" <> show x <> \")\"\n  show Nothing  = \"Nothing\"\n\nderive instance genericMaybe :: Generic (Maybe a) _\n\n-- | Takes a default value, a function, and a `Maybe` value. If the `Maybe`\n-- | value is `Nothing` the default value is returned, otherwise the function\n-- | is applied to the value inside the `Just` and the result is returned.\n-- |\n-- | ``` purescript\n-- | maybe x f Nothing == x\n-- | maybe x f (Just y) == f y\n-- | ```\nmaybe :: forall a b. b -> (a -> b) -> Maybe a -> b\nmaybe b _ Nothing = b\nmaybe _ f (Just a) = f a\n\n-- | Similar to `maybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `maybe` has\n-- | to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | maybe' (\\_ -> x) f Nothing == x\n-- | maybe' (\\_ -> x) f (Just y) == f y\n-- | ```\nmaybe' :: forall a b. (Unit -> b) -> (a -> b) -> Maybe a -> b\nmaybe' g _ Nothing = g unit\nmaybe' _ f (Just a) = f a\n\n-- | Takes a default value, and a `Maybe` value. If the `Maybe` value is\n-- | `Nothing` the default value is returned, otherwise the value inside the\n-- | `Just` is returned.\n-- |\n-- | ``` purescript\n-- | fromMaybe x Nothing == x\n-- | fromMaybe x (Just y) == y\n-- | ```\nfromMaybe :: forall a. a -> Maybe a -> a\nfromMaybe a = maybe a identity\n\n-- | Similar to `fromMaybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromMaybe`\n-- | has to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | fromMaybe' (\\_ -> x) Nothing == x\n-- | fromMaybe' (\\_ -> x) (Just y) == y\n-- | ```\nfromMaybe' :: forall a. (Unit -> a) -> Maybe a -> a\nfromMaybe' a = maybe' a identity\n\n-- | Returns `true` when the `Maybe` value was constructed with `Just`.\nisJust :: forall a. Maybe a -> Boolean\nisJust = maybe false (const true)\n\n-- | Returns `true` when the `Maybe` value is `Nothing`.\nisNothing :: forall a. Maybe a -> Boolean\nisNothing = maybe true (const false)\n\n-- | A partial function that extracts the value from the `Just` data\n-- | constructor. Passing `Nothing` to `fromJust` will throw an error at\n-- | runtime.\nfromJust :: forall a. Partial => Maybe a -> a\nfromJust (Just x) = x\n\n-- | One or none.\n-- |\n-- | ```purescript\n-- | optional empty = pure Nothing\n-- | ```\n-- |\n-- | The behaviour of `optional (pure x)` depends on whether the `Alt` instance\n-- | satisfy the left catch law (`pure a <|> b = pure a`).\n-- |\n-- | `Either e` does:\n-- |\n-- | ```purescript\n-- | optional (Right x) = Right (Just x)\n-- | ```\n-- |\n-- | But `Array` does not:\n-- |\n-- | ```purescript\n-- | optional [x] = [Just x, Nothing]\n-- | ```\noptional :: forall f a. Alt f => Applicative f => f a -> f (Maybe a)\noptional a = map Just a <|> pure Nothing\n", "module Data.Either where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Extend (class Extend)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Maybe (Maybe(..), maybe, maybe')\nimport Data.Ord (class Ord1)\n\n-- | The `Either` type is used to represent a choice between two types of value.\n-- |\n-- | A common use case for `Either` is error handling, where `Left` is used to\n-- | carry an error value and `Right` is used to carry a success value.\ndata Either a b = Left a | Right b\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Right` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Left y == Left y\n-- | ```\nderive instance functorEither :: Functor (Either a)\n\nderive instance genericEither :: Generic (Either a b) _\n\ninstance invariantEither :: Invariant (Either a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions contained within a `Right` to\n-- | transform a value contained within a `Right` using the `(<*>)` operator:\n-- |\n-- | ``` purescript\n-- | Right f <*> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Left f <*> Right x == Left f\n-- | Right f <*> Left y == Left y\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used to transform a\n-- | pure function to take `Either`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Either l a -> Either l b -> Either l c`:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> Right y == Right (f x y)\n-- | ```\n-- |\n-- | The `Left`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Left`\n-- | means the whole result becomes `Left` also, taking the first `Left` value\n-- | found:\n-- |\n-- | ``` purescript\n-- | f <$> Left x <*> Right y == Left x\n-- | f <$> Right x <*> Left y == Left y\n-- | f <$> Left x <*> Left y == Left x\n-- | ```\ninstance applyEither :: Apply (Either e) where\n  apply (Left e) _ = Left e\n  apply (Right f) r = f <$> r\n\n-- | The `Applicative` instance enables lifting of values into `Either` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Either _ _ == Right x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Either` and non-`Either` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Either` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> pure y == Right (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Right` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Right` with a new constructor.\ninstance applicativeEither :: Applicative (Either e) where\n  pure = Right\n\n-- | The `Alt` instance allows for a choice to be made between two `Either`\n-- | values with the `<|>` operator, where the first `Right` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Right x <|> Right y == Right x\n-- | Left x <|> Right y == Right y\n-- | Left x <|> Left y == Left y\n-- | ```\ninstance altEither :: Alt (Either e) where\n  alt (Left _) r = r\n  alt l        _ = l\n\n-- | The `Bind` instance allows sequencing of `Either` values and functions that\n-- | return an `Either` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Left x >>= f = Left x\n-- | Right x >>= f = f x\n-- | ```\n-- |\n-- | `Either`'s \"do notation\" can be understood to work like this:\n-- | ``` purescript\n-- | x :: forall e a. Either e a\n-- | x = --\n-- |\n-- | y :: forall e b. Either e b\n-- | y = --\n-- |\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | ...which is equivalent to...\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | ...and is the same as writing...\n-- |\n-- | ```\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = case x of\n-- |   Left e ->\n-- |     Left e\n-- |   Right x -> case y of\n-- |     Left e ->\n-- |       Left e\n-- |     Right y ->\n-- |       Right (f x y)\n-- | ```\ninstance bindEither :: Bind (Either e) where\n  bind = either (\\e _ -> Left e) (\\a f -> f a)\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Either`.\ninstance monadEither :: Monad (Either e)\n\n-- | The `Extend` instance allows sequencing of `Either` values and functions\n-- | that accept an `Either` and return a non-`Either` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Left x = Left x\n-- | f <<= Right x = Right (f (Right x))\n-- | ```\ninstance extendEither :: Extend (Either e) where\n  extend _ (Left y)  = Left y\n  extend f x         = Right (f x)\n\n-- | The `Show` instance allows `Either` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for both type the `Either` can\n-- | contain.\ninstance showEither :: (Show a, Show b) => Show (Either a b) where\n  show (Left x) = \"(Left \" <> show x <> \")\"\n  show (Right y) = \"(Right \" <> show y <> \")\"\n\n-- | The `Eq` instance allows `Either` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for both\n-- | types the `Either` can contain.\nderive instance eqEither :: (Eq a, Eq b) => Eq (Either a b)\n\nderive instance eq1Either :: Eq a => Eq1 (Either a)\n\n-- | The `Ord` instance allows `Either` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | both types the `Either` can contain.\n-- |\n-- | Any `Left` value is considered to be less than a `Right` value.\nderive instance ordEither :: (Ord a, Ord b) => Ord (Either a b)\n\nderive instance ord1Either :: Ord a => Ord1 (Either a)\n\ninstance boundedEither :: (Bounded a, Bounded b) => Bounded (Either a b) where\n  top = Right top\n  bottom = Left bottom\n\ninstance semigroupEither :: (Semigroup b) => Semigroup (Either a b) where\n  append x y = append <$> x <*> y\n\n-- | Takes two functions and an `Either` value, if the value is a `Left` the\n-- | inner value is applied to the first function, if the value is a `Right`\n-- | the inner value is applied to the second function.\n-- |\n-- | ``` purescript\n-- | either f g (Left x) == f x\n-- | either f g (Right y) == g y\n-- | ```\neither :: forall a b c. (a -> c) -> (b -> c) -> Either a b -> c\neither f _ (Left a) = f a\neither _ g (Right b) = g b\n\n-- | Combine two alternatives.\nchoose :: forall m a b. Alt m => m a -> m b -> m (Either a b)\nchoose a b = Left <$> a <|> Right <$> b\n\n-- | Returns `true` when the `Either` value was constructed with `Left`.\nisLeft :: forall a b. Either a b -> Boolean\nisLeft = either (const true) (const false)\n\n-- | Returns `true` when the `Either` value was constructed with `Right`.\nisRight :: forall a b. Either a b -> Boolean\nisRight = either (const false) (const true)\n\n-- | A function that extracts the value from the `Left` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Right` is passed to `fromLeft`.\nfromLeft :: forall a b. a -> Either a b -> a\nfromLeft _ (Left a) = a\nfromLeft default _ = default\n\n-- | Similar to `fromLeft` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromLeft`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Right`.\nfromLeft' :: forall a b. (Unit -> a) -> Either a b -> a\nfromLeft' _ (Left a) = a\nfromLeft' default _ = default unit\n\n-- | A function that extracts the value from the `Right` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Left` is passed to `fromRight`.\nfromRight :: forall a b. b -> Either a b -> b\nfromRight _ (Right b) = b\nfromRight default _ = default\n\n-- | Similar to `fromRight` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromRight`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Left`.\nfromRight' :: forall a b. (Unit -> b) -> Either a b -> b\nfromRight' _ (Right b) = b\nfromRight' default _ = default unit\n\n-- | Takes a default and a `Maybe` value, if the value is a `Just`, turn it into\n-- | a `Right`, if the value is a `Nothing` use the provided default as a `Left`\n-- |\n-- | ```purescript\n-- | note \"default\" Nothing = Left \"default\"\n-- | note \"default\" (Just 1) = Right 1\n-- | ```\nnote :: forall a b. a -> Maybe b -> Either a b\nnote a = maybe (Left a) Right\n\n-- | Similar to `note`, but for use in cases where the default value may be\n-- | expensive to compute.\n-- |\n-- | ```purescript\n-- | note' (\\_ -> \"default\") Nothing = Left \"default\"\n-- | note' (\\_ -> \"default\") (Just 1) = Right 1\n-- | ```\nnote' :: forall a b. (Unit -> a) -> Maybe b -> Either a b\nnote' f = maybe' (Left <<< f) Right\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Left` values away and converting\n-- | them into `Nothing`. `Right` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | hush (Left \"ParseError\") = Nothing\n-- | hush (Right 42) = Just 42\n-- | ```\nhush :: forall a b. Either a b -> Maybe b\nhush = either (const Nothing) Just\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Right` values away and converting\n-- | them into `Nothing`. `Left` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | blush (Left \"ParseError\") = Just \"Parse Error\"\n-- | blush (Right 42) = Nothing\n-- | ```\nblush :: forall a b. Either a b -> Maybe a\nblush = either Just (const Nothing)\n", "module Control.Lazy where\n\nimport Data.Unit (Unit, unit)\n\n-- | The `Lazy` class represents types which allow evaluation of values\n-- | to be _deferred_.\n-- |\n-- | Usually, this means that a type contains a function arrow which can\n-- | be used to delay evaluation.\nclass Lazy l where\n  defer :: (Unit -> l) -> l\n\ninstance lazyFn :: Lazy (a -> b) where\n  defer f = \\x -> f unit x\n\ninstance lazyUnit :: Lazy Unit where\n  defer _ = unit\n\n-- | `fix` defines a value as the fixed point of a function.\n-- |\n-- | The `Lazy` instance allows us to generate the result lazily.\nfix :: forall l. Lazy l => (l -> l) -> l\nfix f = go\n  where\n    go = defer \\_ -> f go\n", "export const intDegree = function (x) {\n  return Math.min(Math.abs(x), 2147483647);\n};\n\n// See the Euclidean definition in\n// https://en.m.wikipedia.org/wiki/Modulo_operation.\nexport const intDiv = function (x) {\n  return function (y) {\n    if (y === 0) return 0;\n    return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);\n  };\n};\n\nexport const intMod = function (x) {\n  return function (y) {\n    if (y === 0) return 0;\n    var yy = Math.abs(y);\n    return ((x % yy) + yy) % yy;\n  };\n};\n\nexport const numDiv = function (n1) {\n  return function (n2) {\n    return n1 / n2;\n  };\n};\n", "module Data.CommutativeRing\n  ( class CommutativeRing\n  , module Data.Ring\n  , module Data.Semiring\n  , class CommutativeRingRecord\n  ) where\n\nimport Data.Ring (class Ring, class RingRecord)\nimport Data.Semiring (class Semiring, add, mul, one, zero, (*), (+))\nimport Data.Symbol (class IsSymbol)\nimport Data.Unit (Unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Type.Proxy (Proxy)\n\n-- | The `CommutativeRing` class is for rings where multiplication is\n-- | commutative.\n-- |\n-- | Instances must satisfy the following law in addition to the `Ring`\n-- | laws:\n-- |\n-- | - Commutative multiplication: `a * b = b * a`\nclass Ring a <= CommutativeRing a\n\ninstance commutativeRingInt :: CommutativeRing Int\ninstance commutativeRingNumber :: CommutativeRing Number\ninstance commutativeRingUnit :: CommutativeRing Unit\ninstance commutativeRingFn :: CommutativeRing b => CommutativeRing (a -> b)\ninstance commutativeRingRecord :: (RL.RowToList row list, CommutativeRingRecord list row row) => CommutativeRing (Record row)\ninstance commutativeRingProxy :: CommutativeRing (Proxy a)\n\n-- | A class for records where all fields have `CommutativeRing` instances, used\n-- | to implement the `CommutativeRing` instance for records.\nclass RingRecord rowlist row subrow <= CommutativeRingRecord rowlist row subrow | rowlist -> subrow\n\ninstance commutativeRingRecordNil :: CommutativeRingRecord RL.Nil row ()\n\ninstance commutativeRingRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , CommutativeRingRecord rowlistTail row subrowTail\n  , CommutativeRing focus\n  ) =>\n  CommutativeRingRecord (RL.Cons key focus rowlistTail) row subrow\n", "module Data.EuclideanRing\n  ( class EuclideanRing\n  , degree\n  , div\n  , mod\n  , (/)\n  , gcd\n  , lcm\n  , module Data.CommutativeRing\n  , module Data.Ring\n  , module Data.Semiring\n  ) where\n\nimport Data.BooleanAlgebra ((||))\nimport Data.CommutativeRing (class CommutativeRing)\nimport Data.Eq (class Eq, (==))\nimport Data.Ring (class Ring, sub, (-))\nimport Data.Semiring (class Semiring, add, mul, one, zero, (*), (+))\n\n-- | The `EuclideanRing` class is for commutative rings that support division.\n-- | The mathematical structure this class is based on is sometimes also called\n-- | a *Euclidean domain*.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Ring`\n-- | laws:\n-- |\n-- | - Integral domain: `one /= zero`, and if `a` and `b` are both nonzero then\n-- |   so is their product `a * b`\n-- | - Euclidean function `degree`:\n-- |   - Nonnegativity: For all nonzero `a`, `degree a >= 0`\n-- |   - Quotient/remainder: For all `a` and `b`, where `b` is nonzero,\n-- |     let `q = a / b` and ``r = a `mod` b``; then `a = q*b + r`, and also\n-- |     either `r = zero` or `degree r < degree b`\n-- | - Submultiplicative euclidean function:\n-- |   - For all nonzero `a` and `b`, `degree a <= degree (a * b)`\n-- |\n-- | The behaviour of division by `zero` is unconstrained by these laws,\n-- | meaning that individual instances are free to choose how to behave in this\n-- | case. Similarly, there are no restrictions on what the result of\n-- | `degree zero` is; it doesn't make sense to ask for `degree zero` in the\n-- | same way that it doesn't make sense to divide by `zero`, so again,\n-- | individual instances may choose how to handle this case.\n-- |\n-- | For any `EuclideanRing` which is also a `Field`, one valid choice\n-- | for `degree` is simply `const 1`. In fact, unless there's a specific\n-- | reason not to, `Field` types should normally use this definition of\n-- | `degree`.\n-- |\n-- | The `EuclideanRing Int` instance is one of the most commonly used\n-- | `EuclideanRing` instances and deserves a little more discussion. In\n-- | particular, there are a few different sensible law-abiding implementations\n-- | to choose from, with slightly different behaviour in the presence of\n-- | negative dividends or divisors. The most common definitions are \"truncating\"\n-- | division, where the result of `a / b` is rounded towards 0, and \"Knuthian\"\n-- | or \"flooring\" division, where the result of `a / b` is rounded towards\n-- | negative infinity. A slightly less common, but arguably more useful, option\n-- | is \"Euclidean\" division, which is defined so as to ensure that ``a `mod` b``\n-- | is always nonnegative. With Euclidean division, `a / b` rounds towards\n-- | negative infinity if the divisor is positive, and towards positive infinity\n-- | if the divisor is negative. Note that all three definitions are identical if\n-- | we restrict our attention to nonnegative dividends and divisors.\n-- |\n-- | In versions 1.x, 2.x, and 3.x of the Prelude, the `EuclideanRing Int`\n-- | instance used truncating division. As of 4.x, the `EuclideanRing Int`\n-- | instance uses Euclidean division. Additional functions `quot` and `rem` are\n-- | supplied if truncating division is desired.\nclass CommutativeRing a <= EuclideanRing a where\n  degree :: a -> Int\n  div :: a -> a -> a\n  mod :: a -> a -> a\n\ninfixl 7 div as /\n\ninstance euclideanRingInt :: EuclideanRing Int where\n  degree = intDegree\n  div = intDiv\n  mod = intMod\n\ninstance euclideanRingNumber :: EuclideanRing Number where\n  degree _ = 1\n  div = numDiv\n  mod _ _ = 0.0\n\nforeign import intDegree :: Int -> Int\nforeign import intDiv :: Int -> Int -> Int\nforeign import intMod :: Int -> Int -> Int\n\nforeign import numDiv :: Number -> Number -> Number\n\n-- | The *greatest common divisor* of two values.\ngcd :: forall a. Eq a => EuclideanRing a => a -> a -> a\ngcd a b =\n  if b == zero then a\n  else gcd b (a `mod` b)\n\n-- | The *least common multiple* of two values.\nlcm :: forall a. Eq a => EuclideanRing a => a -> a -> a\nlcm a b =\n  if a == zero || b == zero then zero\n  else a * b / gcd a b\n", "-- | A data type and functions for working with ordered pairs.\nmodule Data.Tuple where\n\nimport Prelude\n\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy, defer)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.HeytingAlgebra (implies, ff, tt)\nimport Data.Ord (class Ord1)\n\n-- | A simple product type for wrapping a pair of component values.\ndata Tuple a b = Tuple a b\n\n-- | Allows `Tuple`s to be rendered as a string with `show` whenever there are\n-- | `Show` instances for both component types.\ninstance showTuple :: (Show a, Show b) => Show (Tuple a b) where\n  show (Tuple a b) = \"(Tuple \" <> show a <> \" \" <> show b <> \")\"\n\n-- | Allows `Tuple`s to be checked for equality with `==` and `/=` whenever\n-- | there are `Eq` instances for both component types.\nderive instance eqTuple :: (Eq a, Eq b) => Eq (Tuple a b)\n\nderive instance eq1Tuple :: Eq a => Eq1 (Tuple a)\n\n-- | Allows `Tuple`s to be compared with `compare`, `>`, `>=`, `<` and `<=`\n-- | whenever there are `Ord` instances for both component types. To obtain\n-- | the result, the `fst`s are `compare`d, and if they are `EQ`ual, the\n-- | `snd`s are `compare`d.\nderive instance ordTuple :: (Ord a, Ord b) => Ord (Tuple a b)\n\nderive instance ord1Tuple :: Ord a => Ord1 (Tuple a)\n\ninstance boundedTuple :: (Bounded a, Bounded b) => Bounded (Tuple a b) where\n  top = Tuple top top\n  bottom = Tuple bottom bottom\n\ninstance semigroupoidTuple :: Semigroupoid Tuple where\n  compose (Tuple _ c) (Tuple a _) = Tuple a c\n\n-- | The `Semigroup` instance enables use of the associative operator `<>` on\n-- | `Tuple`s whenever there are `Semigroup` instances for the component\n-- | types. The `<>` operator is applied pairwise, so:\n-- | ```purescript\n-- | (Tuple a1 b1) <> (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n-- | ```\ninstance semigroupTuple :: (Semigroup a, Semigroup b) => Semigroup (Tuple a b) where\n  append (Tuple a1 b1) (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n\ninstance monoidTuple :: (Monoid a, Monoid b) => Monoid (Tuple a b) where\n  mempty = Tuple mempty mempty\n\ninstance semiringTuple :: (Semiring a, Semiring b) => Semiring (Tuple a b) where\n  add (Tuple x1 y1) (Tuple x2 y2) = Tuple (add x1 x2) (add y1 y2)\n  one = Tuple one one\n  mul (Tuple x1 y1) (Tuple x2 y2) = Tuple (mul x1 x2) (mul y1 y2)\n  zero = Tuple zero zero\n\ninstance ringTuple :: (Ring a, Ring b) => Ring (Tuple a b) where\n  sub (Tuple x1 y1) (Tuple x2 y2) = Tuple (sub x1 x2) (sub y1 y2)\n\ninstance commutativeRingTuple :: (CommutativeRing a, CommutativeRing b) => CommutativeRing (Tuple a b)\n\ninstance heytingAlgebraTuple :: (HeytingAlgebra a, HeytingAlgebra b) => HeytingAlgebra (Tuple a b) where\n  tt = Tuple tt tt\n  ff = Tuple ff ff\n  implies (Tuple x1 y1) (Tuple x2 y2) = Tuple (x1 `implies` x2) (y1 `implies` y2)\n  conj (Tuple x1 y1) (Tuple x2 y2) = Tuple (conj x1 x2) (conj y1 y2)\n  disj (Tuple x1 y1) (Tuple x2 y2) = Tuple (disj x1 x2) (disj y1 y2)\n  not (Tuple x y) = Tuple (not x) (not y)\n\ninstance booleanAlgebraTuple :: (BooleanAlgebra a, BooleanAlgebra b) => BooleanAlgebra (Tuple a b)\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<$>` operator, applying the function to the second\n-- | component, so:\n-- | ```purescript\n-- | f <$> (Tuple x y) = Tuple x (f y)\n-- | ````\nderive instance functorTuple :: Functor (Tuple a)\n\nderive instance genericTuple :: Generic (Tuple a b) _\n\ninstance invariantTuple :: Invariant (Tuple a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<*>` operator whenever there is a `Semigroup` instance\n-- | for the `fst` component, so:\n-- | ```purescript\n-- | (Tuple a1 f) <*> (Tuple a2 x) == Tuple (a1 <> a2) (f x)\n-- | ```\ninstance applyTuple :: (Semigroup a) => Apply (Tuple a) where\n  apply (Tuple a1 f) (Tuple a2 x) = Tuple (a1 <> a2) (f x)\n\ninstance applicativeTuple :: (Monoid a) => Applicative (Tuple a) where\n  pure = Tuple mempty\n\ninstance bindTuple :: (Semigroup a) => Bind (Tuple a) where\n  bind (Tuple a1 b) f = case f b of\n    Tuple a2 c -> Tuple (a1 <> a2) c\n\ninstance monadTuple :: (Monoid a) => Monad (Tuple a)\n\ninstance extendTuple :: Extend (Tuple a) where\n  extend f t@(Tuple a _) = Tuple a (f t)\n\ninstance comonadTuple :: Comonad (Tuple a) where\n  extract = snd\n\ninstance lazyTuple :: (Lazy a, Lazy b) => Lazy (Tuple a b) where\n  defer f = Tuple (defer $ \\_ -> fst (f unit)) (defer $ \\_ -> snd (f unit))\n\n-- | Returns the first component of a tuple.\nfst :: forall a b. Tuple a b -> a\nfst (Tuple a _) = a\n\n-- | Returns the second component of a tuple.\nsnd :: forall a b. Tuple a b -> b\nsnd (Tuple _ b) = b\n\n-- | Turn a function that expects a tuple into a function of two arguments.\ncurry :: forall a b c. (Tuple a b -> c) -> a -> b -> c\ncurry f a b = f (Tuple a b)\n\n-- | Turn a function of two arguments into a function that expects a tuple.\nuncurry :: forall a b c. (a -> b -> c) -> Tuple a b -> c\nuncurry f (Tuple a b) = f a b\n\n-- | Exchange the first and second components of a tuple.\nswap :: forall a b. Tuple a b -> Tuple b a\nswap (Tuple a b) = Tuple b a\n", "module Data.Bifunctor where\n\nimport Control.Category (identity)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Tuple (Tuple(..))\n\n-- | A `Bifunctor` is a `Functor` from the pair category `(Type, Type)` to `Type`.\n-- |\n-- | A type constructor with two type arguments can be made into a `Bifunctor` if\n-- | both of its type arguments are covariant.\n-- |\n-- | The `bimap` function maps a pair of functions over the two type arguments\n-- | of the bifunctor.\n-- |\n-- | Laws:\n-- |\n-- | - Identity: `bimap identity identity == identity`\n-- | - Composition: `bimap f1 g1 <<< bimap f2 g2 == bimap (f1 <<< f2) (g1 <<< g2)`\n-- |\nclass Bifunctor f where\n  bimap :: forall a b c d. (a -> b) -> (c -> d) -> f a c -> f b d\n\n-- | Map a function over the first type argument of a `Bifunctor`.\nlmap :: forall f a b c. Bifunctor f => (a -> b) -> f a c -> f b c\nlmap f = bimap f identity\n\n-- | Map a function over the second type arguments of a `Bifunctor`.\nrmap :: forall f a b c. Bifunctor f => (b -> c) -> f a b -> f a c\nrmap = bimap identity\n\ninstance bifunctorEither :: Bifunctor Either where\n  bimap f _ (Left l) = Left (f l)\n  bimap _ g (Right r) = Right (g r)\n\ninstance bifunctorTuple :: Bifunctor Tuple where\n  bimap f g (Tuple x y) = Tuple (f x) (g y)\n\ninstance bifunctorConst :: Bifunctor Const where\n  bimap f _ (Const a) = Const (f a)\n", "export const _localeCompare = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (s1) {\n        return function (s2) {\n          var result = s1.localeCompare(s2);\n          return result < 0 ? lt : result > 0 ? gt : eq;\n        };\n      };\n    };\n  };\n};\n\nexport const replace = function (s1) {\n  return function (s2) {\n    return function (s3) {\n      return s3.replace(s1, s2);\n    };\n  };\n};\n\nexport const replaceAll = function (s1) {\n  return function (s2) {\n    return function (s3) {\n      return s3.replace(new RegExp(s1.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), \"g\"), s2); // eslint-disable-line no-useless-escape\n    };\n  };\n};\n\nexport const split = function (sep) {\n  return function (s) {\n    return s.split(sep);\n  };\n};\n\nexport const toLower = function (s) {\n  return s.toLowerCase();\n};\n\nexport const toUpper = function (s) {\n  return s.toUpperCase();\n};\n\nexport const trim = function (s) {\n  return s.trim();\n};\n\nexport const joinWith = function (s) {\n  return function (xs) {\n    return xs.join(s);\n  };\n};\n", "module Data.String.Common\n  ( null\n  , localeCompare\n  , replace\n  , replaceAll\n  , split\n  , toLower\n  , toUpper\n  , trim\n  , joinWith\n  ) where\n\nimport Prelude\n\nimport Data.String.Pattern (Pattern, Replacement)\n\n-- | Returns `true` if the given string is empty.\n-- |\n-- | ```purescript\n-- | null \"\" == true\n-- | null \"Hi\" == false\n-- | ```\nnull :: String -> Boolean\nnull s = s == \"\"\n\n-- | Compare two strings in a locale-aware fashion. This is in contrast to\n-- | the `Ord` instance on `String` which treats strings as arrays of code\n-- | units:\n-- |\n-- | ```purescript\n-- | \"\u00E4\" `localeCompare` \"b\" == LT\n-- | \"\u00E4\" `compare` \"b\" == GT\n-- | ```\nlocaleCompare :: String -> String -> Ordering\nlocaleCompare = _localeCompare LT EQ GT\n\nforeign import _localeCompare\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> String\n  -> String\n  -> Ordering\n\n-- | Replaces the first occurence of the pattern with the replacement string.\n-- |\n-- | ```purescript\n-- | replace (Pattern \"<=\") (Replacement \"\u2264\") \"a <= b <= c\" == \"a \u2264 b <= c\"\n-- | ```\nforeign import replace :: Pattern -> Replacement -> String -> String\n\n-- | Replaces all occurences of the pattern with the replacement string.\n-- |\n-- | ```purescript\n-- | replaceAll (Pattern \"<=\") (Replacement \"\u2264\") \"a <= b <= c\" == \"a \u2264 b \u2264 c\"\n-- | ```\nforeign import replaceAll :: Pattern -> Replacement -> String -> String\n\n-- | Returns the substrings of the second string separated along occurences\n-- | of the first string.\n-- |\n-- | ```purescript\n-- | split (Pattern \" \") \"hello world\" == [\"hello\", \"world\"]\n-- | ```\nforeign import split :: Pattern -> String -> Array String\n\n-- | Returns the argument converted to lowercase.\n-- |\n-- | ```purescript\n-- | toLower \"hElLo\" == \"hello\"\n-- | ```\nforeign import toLower :: String -> String\n\n-- | Returns the argument converted to uppercase.\n-- |\n-- | ```purescript\n-- | toUpper \"Hello\" == \"HELLO\"\n-- | ```\nforeign import toUpper :: String -> String\n\n-- | Removes whitespace from the beginning and end of a string, including\n-- | [whitespace characters](http://www.ecma-international.org/ecma-262/5.1/#sec-7.2)\n-- | and [line terminators](http://www.ecma-international.org/ecma-262/5.1/#sec-7.3).\n-- |\n-- | ```purescript\n-- | trim \"   Hello  \\n World\\n\\t    \" == \"Hello  \\n World\"\n-- | ```\nforeign import trim :: String -> String\n\n-- | Joins the strings in the array together, inserting the first argument\n-- | as separator between them.\n-- |\n-- | ```purescript\n-- | joinWith \", \" [\"apple\", \"banana\", \"orange\"] == \"apple, banana, orange\"\n-- | ```\nforeign import joinWith :: String -> Array String -> String\n", "module Control.Bind\n  ( class Bind\n  , bind\n  , (>>=)\n  , bindFlipped\n  , (=<<)\n  , class Discard\n  , discard\n  , join\n  , composeKleisli\n  , (>=>)\n  , composeKleisliFlipped\n  , (<=<)\n  , ifM\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Category (identity)\n\nimport Data.Function (flip)\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bind` type class extends the [`Apply`](#apply) type class with a\n-- | \"bind\" operation `(>>=)` which composes computations in sequence, using\n-- | the return value of one computation to determine the next computation.\n-- |\n-- | The `>>=` operator can also be expressed using `do` notation, as follows:\n-- |\n-- | ```purescript\n-- | x >>= f = do y <- x\n-- |              f y\n-- | ```\n-- |\n-- | where the function argument of `f` is given the name `y`.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Associativity: `(x >>= f) >>= g = x >>= (\\k -> f k >>= g)`\n-- | - Apply Superclass: `apply f x = f >>= \\f\u2019 -> map f\u2019 x`\n-- |\n-- | Associativity tells us that we can regroup operations which use `do`\n-- | notation so that we can unambiguously write, for example:\n-- |\n-- | ```purescript\n-- | do x <- m1\n-- |    y <- m2 x\n-- |    m3 x y\n-- | ```\nclass Apply m <= Bind m where\n  bind :: forall a b. m a -> (a -> m b) -> m b\n\ninfixl 1 bind as >>=\n\n-- | `bindFlipped` is `bind` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | print =<< random\n-- | ```\nbindFlipped :: forall m a b. Bind m => (a -> m b) -> m a -> m b\nbindFlipped = flip bind\n\ninfixr 1 bindFlipped as =<<\n\ninstance bindFn :: Bind ((->) r) where\n  bind m f x = f (m x) x\n\n-- | The `bind`/`>>=` function for `Array` works by applying a function to\n-- | each element in the array, and flattening the results into a single,\n-- | new array.\n-- |\n-- | Array's `bind`/`>>=` works like a nested for loop. Each `bind` adds\n-- | another level of nesting in the loop. For example:\n-- | ```\n-- | foo :: Array String\n-- | foo =\n-- |   [\"a\", \"b\"] >>= \\eachElementInArray1 ->\n-- |     [\"c\", \"d\"] >>= \\eachElementInArray2\n-- |       pure (eachElementInArray1 <> eachElementInArray2)\n-- |\n-- | -- In other words...\n-- | foo\n-- | -- ... is the same as...\n-- | [ (\"a\" <> \"c\"), (\"a\" <> \"d\"), (\"b\" <> \"c\"), (\"b\" <> \"d\") ]\n-- | -- which simplifies to...\n-- | [ \"ac\", \"ad\", \"bc\", \"bd\" ]\n-- | ```\ninstance bindArray :: Bind Array where\n  bind = arrayBind\n\nforeign import arrayBind :: forall a b. Array a -> (a -> Array b) -> Array b\n\ninstance bindProxy :: Bind Proxy where\n  bind _ _ = Proxy\n\n-- | A class for types whose values can safely be discarded\n-- | in a `do` notation block.\n-- |\n-- | An example is the `Unit` type, since there is only one\n-- | possible value which can be returned.\nclass Discard a where\n  discard :: forall f b. Bind f => f a -> (a -> f b) -> f b\n\ninstance discardUnit :: Discard Unit where\n  discard = bind\n\ninstance discardProxy :: Discard (Proxy a) where\n  discard = bind\n\n-- | Collapse two applications of a monadic type constructor into one.\njoin :: forall a m. Bind m => m (m a) -> m a\njoin m = m >>= identity\n\n-- | Forwards Kleisli composition.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Data.Array (head, tail)\n-- |\n-- | third = tail >=> tail >=> head\n-- | ```\ncomposeKleisli :: forall a b c m. Bind m => (a -> m b) -> (b -> m c) -> a -> m c\ncomposeKleisli f g a = f a >>= g\n\ninfixr 1 composeKleisli as >=>\n\n-- | Backwards Kleisli composition.\ncomposeKleisliFlipped :: forall a b c m. Bind m => (b -> m c) -> (a -> m b) -> a -> m c\ncomposeKleisliFlipped f g a = f =<< g a\n\ninfixr 1 composeKleisliFlipped as <=<\n\n-- | Execute a monadic action if a condition holds.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = ifM ((< 0.5) <$> random)\n-- |          (trace \"Heads\")\n-- |          (trace \"Tails\")\n-- | ```\nifM :: forall a m. Bind m => m Boolean -> m a -> m a -> m a\nifM cond t f = cond >>= \\cond' -> if cond' then t else f\n", "-- | This module defines the `MonadError` type class and its instances.\n\nmodule Control.Monad.Error.Class where\n\nimport Prelude\n\nimport Data.Either (Either(..), either)\nimport Data.Maybe (Maybe(..), maybe)\nimport Effect (Effect)\nimport Effect.Exception as Ex\n\n\n-- | The `MonadThrow` type class represents those monads which support errors via\n-- | `throwError`, where `throwError e` halts, yielding the error `e`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Left zero: `throwError e >>= f = throwError e`\n-- |\nclass Monad m <= MonadThrow e m | m -> e where\n  throwError :: forall a. e -> m a\n\n-- | The `MonadError` type class represents those monads which support catching\n-- | errors.\n-- |\n-- | - `catchError x f` calls the error handler `f` if an error is thrown during the\n-- |   evaluation of `x`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Catch: `catchError (throwError e) f = f e`\n-- | - Pure: `catchError (pure a) f = pure a`\n-- |\nclass MonadThrow e m <= MonadError e m | m -> e where\n  catchError :: forall a. m a -> (e -> m a) -> m a\n\n-- | This function allows you to provide a predicate for selecting the\n-- | exceptions that you're interested in, and handle only those exceptons.\n-- | If the inner computation throws an exception, and the predicate returns\n-- | Nothing, then the whole computation will still fail with that exception.\ncatchJust\n  :: forall e m a b\n   . MonadError e m\n  => (e -> Maybe b) -- ^ Predicate to select exceptions\n  -> m a            -- ^ Computation to run\n  -> (b -> m a)     -- ^ Handler\n  -> m a\ncatchJust p act handler = catchError act handle\n  where\n  handle e =\n    case p e of\n      Nothing -> throwError e\n      Just b -> handler b\n\n-- | Return `Right` if the given action succeeds, `Left` if it throws.\ntry\n  :: forall e m a\n   . MonadError e m\n  => m a\n  -> m (Either e a)\ntry a = (Right <$> a) `catchError` (pure <<< Left)\n\ninstance monadThrowEither :: MonadThrow e (Either e) where\n  throwError = Left\n\ninstance monadErrorEither :: MonadError e (Either e) where\n  catchError (Left e) h = h e\n  catchError (Right x) _ = Right x\n\ninstance monadThrowMaybe :: MonadThrow Unit Maybe where\n  throwError = const Nothing\n\ninstance monadErrorMaybe :: MonadError Unit Maybe where\n  catchError Nothing f  = f unit\n  catchError (Just a) _ = Just a\n \ninstance monadThrowEffect :: MonadThrow Ex.Error Effect where\n  throwError = Ex.throwException\n\ninstance monadErrorEffect :: MonadError Ex.Error Effect where\n  catchError = flip Ex.catchException\n\n\n-- | Make sure that a resource is cleaned up in the event of an exception. The\n-- | release action is called regardless of whether the body action throws or\n-- | returns.\nwithResource\n  :: forall e m r a\n   . MonadError e m\n  => m r\n  -> (r -> m Unit)\n  -> (r -> m a)\n  -> m a\nwithResource acquire release kleisli = do\n  resource <- acquire\n  result <- try $ kleisli resource\n  release resource\n  either throwError pure result\n\n-- | Lift a `Maybe` value to a MonadThrow monad.\nliftMaybe :: forall m e a. MonadThrow e m => e -> Maybe a -> m a\nliftMaybe error = maybe (throwError error) pure\n\n-- | Lift an `Either` value to a MonadThrow monad.\nliftEither :: forall m e a. MonadThrow e m => Either e a -> m a\nliftEither = either throwError pure\n", "module Data.Identity where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1)\n\nnewtype Identity a = Identity a\n\nderive instance newtypeIdentity :: Newtype (Identity a) _\n\nderive newtype instance eqIdentity :: Eq a => Eq (Identity a)\n\nderive newtype instance ordIdentity :: Ord a => Ord (Identity a)\n\nderive newtype instance boundedIdentity :: Bounded a => Bounded (Identity a)\n\nderive newtype instance heytingAlgebraIdentity :: HeytingAlgebra a => HeytingAlgebra (Identity a)\n\nderive newtype instance booleanAlgebraIdentity :: BooleanAlgebra a => BooleanAlgebra (Identity a)\n\nderive newtype instance semigroupIdentity :: Semigroup a => Semigroup (Identity a)\n\nderive newtype instance monoidIdentity :: Monoid a => Monoid (Identity a)\n\nderive newtype instance semiringIdentity :: Semiring a => Semiring (Identity a)\n\nderive newtype instance euclideanRingIdentity :: EuclideanRing a => EuclideanRing (Identity a)\n\nderive newtype instance ringIdentity :: Ring a => Ring (Identity a)\n\nderive newtype instance commutativeRingIdentity :: CommutativeRing a => CommutativeRing (Identity a)\n\nderive newtype instance lazyIdentity :: Lazy a => Lazy (Identity a)\n\ninstance showIdentity :: Show a => Show (Identity a) where\n  show (Identity x) = \"(Identity \" <> show x <> \")\"\n\nderive instance eq1Identity :: Eq1 Identity\n\nderive instance ord1Identity :: Ord1 Identity\n\nderive instance functorIdentity :: Functor Identity\n\ninstance invariantIdentity :: Invariant Identity where\n  imap = imapF\n\ninstance altIdentity :: Alt Identity where\n  alt x _ = x\n\ninstance applyIdentity :: Apply Identity where\n  apply (Identity f) (Identity x) = Identity (f x)\n\ninstance applicativeIdentity :: Applicative Identity where\n  pure = Identity\n\ninstance bindIdentity :: Bind Identity where\n  bind (Identity m) f = f m\n\ninstance monadIdentity :: Monad Identity\n\ninstance extendIdentity :: Extend Identity where\n  extend f m = Identity (f m)\n\ninstance comonadIdentity :: Comonad Identity where\n  extract (Identity x) = x\n", "module Control.Monad.Rec.Class\n  ( Step(..)\n  , class MonadRec\n  , tailRec\n  , tailRec2\n  , tailRec3\n  , tailRecM\n  , tailRecM2\n  , tailRecM3\n  , forever\n  , whileJust\n  , untilJust\n  , loop2\n  , loop3\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Either (Either(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect, untilE)\nimport Effect.Ref as Ref\nimport Partial.Unsafe (unsafePartial)\n\n-- | The result of a computation: either `Loop` containing the updated\n-- | accumulator, or `Done` containing the final result of the computation.\ndata Step a b = Loop a | Done b\n\nderive instance functorStep :: Functor (Step a)\n\ninstance bifunctorStep :: Bifunctor Step where\n  bimap f _ (Loop a) = Loop (f a)\n  bimap _ g (Done b) = Done (g b)\n\n-- | This type class captures those monads which support tail recursion in\n-- | constant stack space.\n-- |\n-- | The `tailRecM` function takes a step function, and applies that step\n-- | function recursively until a pure value of type `b` is found.\n-- |\n-- | Instances are provided for standard monad transformers.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | loopWriter :: Int -> WriterT (Additive Int) Effect Unit\n-- | loopWriter n = tailRecM go n\n-- |   where\n-- |   go 0 = do\n-- |     traceM \"Done!\"\n-- |     pure (Done unit)\n-- |   go i = do\n-- |     tell $ Additive i\n-- |     pure (Loop (i - 1))\n-- | ```\nclass Monad m <= MonadRec m where\n  tailRecM :: forall a b. (a -> m (Step a b)) -> a -> m b\n\n-- | Create a tail-recursive function of two arguments which uses constant stack space.\n-- |\n-- | The `loop2` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRecM2\n  :: forall m a b c\n   . MonadRec m\n  => (a -> b -> m (Step { a :: a, b :: b } c))\n  -> a\n  -> b\n  -> m c\ntailRecM2 f a b = tailRecM (\\o -> f o.a o.b) { a, b }\n\n-- | Create a tail-recursive function of three arguments which uses constant stack space.\n-- |\n-- | The `loop3` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRecM3\n  :: forall m a b c d\n   . MonadRec m\n  => (a -> b -> c -> m (Step { a :: a, b :: b, c :: c } d))\n  -> a\n  -> b\n  -> c\n  -> m d\ntailRecM3 f a b c = tailRecM (\\o -> f o.a o.b o.c) { a, b, c }\n\n-- | Create a pure tail-recursive function of one argument\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | pow :: Int -> Int -> Int\n-- | pow n p = tailRec go { accum: 1, power: p }\n-- |   where\n-- |   go :: _ -> Step _ Int\n-- |   go { accum: acc, power: 0 } = Done acc\n-- |   go { accum: acc, power: p } = Loop { accum: acc * n, power: p - 1 }\n-- | ```\ntailRec :: forall a b. (a -> Step a b) -> a -> b\ntailRec f = go <<< f\n  where\n  go (Loop a) = go (f a)\n  go (Done b) = b\n\n-- | Create a pure tail-recursive function of two arguments\n-- |\n-- | The `loop2` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRec2 :: forall a b c. (a -> b -> Step { a :: a, b :: b } c) -> a -> b -> c\ntailRec2 f a b = tailRec (\\o -> f o.a o.b) { a, b }\n\n-- | Create a pure tail-recursive function of three arguments\n-- |\n-- | The `loop3` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRec3 :: forall a b c d. (a -> b -> c -> Step { a :: a, b :: b, c :: c } d) -> a -> b -> c -> d\ntailRec3 f a b c = tailRec (\\o -> f o.a o.b o.c) { a, b, c }\n\ninstance monadRecIdentity :: MonadRec Identity where\n  tailRecM f = Identity <<< tailRec (runIdentity <<< f)\n    where runIdentity (Identity x) = x\n\ninstance monadRecEffect :: MonadRec Effect where\n  tailRecM f a = do\n    r <- Ref.new =<< f a\n    untilE do\n      Ref.read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          _ <- Ref.write e r\n          pure false\n        Done _ -> pure true\n    fromDone <$> Ref.read r\n    where\n    fromDone :: forall a b. Step a b -> b\n    fromDone = unsafePartial \\(Done b) -> b\n\ninstance monadRecFunction :: MonadRec ((->) e) where\n  tailRecM f a0 e = tailRec (\\a -> f a e) a0\n\ninstance monadRecEither :: MonadRec (Either e) where\n  tailRecM f a0 =\n    let\n      g (Left e) = Done (Left e)\n      g (Right (Loop a)) = Loop (f a)\n      g (Right (Done b)) = Done (Right b)\n    in tailRec g (f a0)\n\ninstance monadRecMaybe :: MonadRec Maybe where\n  tailRecM f a0 =\n    let\n      g Nothing = Done Nothing\n      g (Just (Loop a)) = Loop (f a)\n      g (Just (Done b)) = Done (Just b)\n    in tailRec g (f a0)\n\n-- | `forever` runs an action indefinitely, using the `MonadRec` instance to\n-- | ensure constant stack usage.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = forever $ trace \"Hello, World!\"\n-- | ```\nforever :: forall m a b. MonadRec m => m a -> m b\nforever ma = tailRecM (\\u -> Loop u <$ ma) unit\n\n-- | While supplied computation evaluates to `Just _`, it will be\n-- | executed repeatedly and results will be combined using monoid instance.\nwhileJust :: forall a m. Monoid a => MonadRec m => m (Maybe a) -> m a\nwhileJust m = mempty # tailRecM \\v -> m <#> case _ of\n  Nothing -> Done v\n  Just x -> Loop $ v <> x\n\n-- | Supplied computation will be executed repeatedly until it evaluates\n-- | to `Just value` and then that `value` will be returned.\nuntilJust :: forall a m. MonadRec m => m (Maybe a) -> m a\nuntilJust m = unit # tailRecM \\_ -> m <#> case _ of\n  Nothing -> Loop unit\n  Just x -> Done x\n\n-- | A curried version of the `Loop` constructor, provided as a convenience for\n-- | use with `tailRec2` and `tailRecM2`.\nloop2 :: forall a b c. a -> b -> Step { a :: a, b :: b } c\nloop2 a b = Loop { a, b }\n\n-- | A curried version of the `Loop` constructor, provided as a convenience for\n-- | use with `tailRec3` and `tailRecM3`.\nloop3 :: forall a b c d. a -> b -> c -> Step { a :: a, b :: b, c :: c } d\nloop3 a b c = Loop { a, b, c }\n", "export const defer = function (thunk) {\n  var v = null;\n  return function() {\n    if (thunk === undefined) return v;\n\n    v = thunk();\n    thunk = undefined; // eslint-disable-line no-param-reassign\n    return v;\n  };\n};\n\nexport const force = function (l) {\n  return l();\n};\n", "// module Unsafe.Coerce\n\nexport const unsafeCoerce = function (x) {\n  return x;\n};\n", "module Safe.Coerce\n  ( module Prim.Coerce\n  , coerce\n  ) where\n\nimport Prim.Coerce (class Coercible)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Coerce a value of one type to a value of some other type, without changing\n-- | its runtime representation. This function behaves identically to\n-- | `unsafeCoerce` at runtime. Unlike `unsafeCoerce`, it is safe, because the\n-- | `Coercible` constraint prevents any use of this function from compiling\n-- | unless the compiler can prove that the two types have the same runtime\n-- | representation.\n-- |\n-- | One application for this function is to avoid doing work that you know is a\n-- | no-op because of newtypes. For example, if you have an `Array (Conj a)` and you\n-- | want an `Array (Disj a)`, you could do `Data.Array.map (un Conj >>> Disj)`, but\n-- | this performs an unnecessary traversal of the array, with O(n) cost.\n-- | `coerce` accomplishes the same with only O(1) cost:\n-- |\n-- | ```purescript\n-- | mapConjToDisj :: forall a. Array (Conj a) -> Array (Disj a)\n-- | mapConjToDisj = coerce\n-- | ```\ncoerce :: forall a b. Coercible a b => a -> b\ncoerce = unsafeCoerce\n", "module Data.Newtype where\n\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Semigroup.First (First(..))\nimport Data.Semigroup.Last (Last(..))\nimport Safe.Coerce (class Coercible, coerce)\n\n-- | A type class for `newtype`s to enable convenient wrapping and unwrapping,\n-- | and the use of the other functions in this module.\n-- |\n-- | The compiler can derive instances of `Newtype` automatically:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- |\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- | ```\n-- |\n-- | Note that deriving for `Newtype` instances requires that the type be\n-- | defined as `newtype` rather than `data` declaration (even if the `data`\n-- | structurally fits the rules of a `newtype`), and the use of a wildcard for\n-- | the wrapped type.\nclass Newtype :: Type -> Type -> Constraint\nclass Coercible t a <= Newtype t a | t -> a\n\nwrap :: forall t a. Newtype t a => a -> t\nwrap = coerce\n\nunwrap :: forall t a. Newtype t a => t -> a\nunwrap = coerce\n\ninstance newtypeAdditive :: Newtype (Additive a) a\n\ninstance newtypeMultiplicative :: Newtype (Multiplicative a) a\n\ninstance newtypeConj :: Newtype (Conj a) a\n\ninstance newtypeDisj :: Newtype (Disj a) a\n\ninstance newtypeDual :: Newtype (Dual a) a\n\ninstance newtypeEndo :: Newtype (Endo c a) (c a a)\n\ninstance newtypeFirst :: Newtype (First a) a\n\ninstance newtypeLast :: Newtype (Last a) a\n\n-- | Given a constructor for a `Newtype`, this returns the appropriate `unwrap`\n-- | function.\nun :: forall t a. Newtype t a => (a -> t) -> t -> a\nun _ = unwrap\n\n-- | This combinator unwraps the newtype, applies a monomorphic function to the \n-- | contained value and wraps the result back in the newtype\nmodify :: forall t a. Newtype t a => (a -> a) -> t -> t\nmodify fn t = wrap (fn (unwrap t))\n\n-- | This combinator is for when you have a higher order function that you want\n-- | to use in the context of some newtype - `foldMap` being a common example:\n-- |\n-- | ``` purescript\n-- | ala Additive foldMap [1,2,3,4] -- 10\n-- | ala Multiplicative foldMap [1,2,3,4] -- 24\n-- | ala Conj foldMap [true, false] -- false\n-- | ala Disj foldMap [true, false] -- true\n-- | ```\nala\n  :: forall f t a s b\n   . Coercible (f t) (f a)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> ((b -> s) -> f t)\n  -> f a\nala _ f = coerce (f wrap)\n\n-- | Similar to `ala` but useful for cases where you want to use an additional\n-- | projection with the higher order function:\n-- |\n-- | ``` purescript\n-- | alaF Additive foldMap String.length [\"hello\", \"world\"] -- 10\n-- | alaF Multiplicative foldMap Math.abs [1.0, -2.0, 3.0, -4.0] -- 24.0\n-- | ```\n-- |\n-- | The type admits other possibilities due to the polymorphic `Functor`\n-- | constraints, but the case described above works because ((->) a) is a\n-- | `Functor`.\nalaF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nalaF _ = coerce\n\n-- | Lifts a function operate over newtypes. This can be used to lift a\n-- | function to manipulate the contents of a single newtype, somewhat like\n-- | `map` does for a `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype Label = Label String\n-- | derive instance newtypeLabel :: Newtype Label _\n-- |\n-- | toUpperLabel :: Label -> Label\n-- | toUpperLabel = over Label String.toUpper\n-- | ```\n-- |\n-- | But the result newtype is polymorphic, meaning the result can be returned\n-- | as an alternative newtype:\n-- |\n-- | ``` purescript\n-- | newtype UppercaseLabel = UppercaseLabel String\n-- | derive instance newtypeUppercaseLabel :: Newtype UppercaseLabel _\n-- |\n-- | toUpperLabel' :: Label -> UppercaseLabel\n-- | toUpperLabel' = over Label String.toUpper\n-- | ```\nover\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> b)\n  -> t\n  -> s\nover _ = coerce\n\n-- | Much like `over`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | findLabel :: String -> Array Label -> Maybe Label\n-- | findLabel s = overF Label (Foldable.find (_ == s))\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\noverF\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> g b)\n  -> f t\n  -> g s\noverF _ = coerce\n\n-- | The opposite of `over`: lowers a function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\n-- |\n-- | ``` purescript\n-- | newtype Degrees = Degrees Number\n-- | derive instance newtypeDegrees :: Newtype Degrees _\n-- |\n-- | newtype NormalDegrees = NormalDegrees Number\n-- | derive instance newtypeNormalDegrees :: Newtype NormalDegrees _\n-- |\n-- | normaliseDegrees :: Degrees -> NormalDegrees\n-- | normaliseDegrees (Degrees deg) = NormalDegrees (deg % 360.0)\n-- |\n-- | asNormalDegrees :: Number -> Number\n-- | asNormalDegrees = under Degrees normaliseDegrees\n-- | ```\n-- |\n-- | As with `over` the `Newtype` is polymorphic, as illustrated in the example\n-- | above - both `Degrees` and `NormalDegrees` are instances of `Newtype`,\n-- | so even though `normaliseDegrees` changes the result type we can still put\n-- | a `Number` in and get a `Number` out via `under`.\nunder\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> s)\n  -> a\n  -> b\nunder _ = coerce\n\n-- | Much like `under`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- |\n-- | isValid :: EmailAddress -> Boolean\n-- | isValid x = false -- imagine a slightly less strict predicate here\n-- |\n-- | findValidEmailString :: Array String -> Maybe String\n-- | findValidEmailString = underF EmailAddress (Foldable.find isValid)\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\nunderF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nunderF _ = coerce\n\n-- | Lifts a binary function to operate over newtypes.\n-- |\n-- | ``` purescript\n-- | newtype Meter = Meter Int\n-- | derive newtype instance newtypeMeter :: Newtype Meter _\n-- | newtype SquareMeter = SquareMeter Int\n-- | derive newtype instance newtypeSquareMeter :: Newtype SquareMeter _\n-- |\n-- | area :: Meter -> Meter -> SquareMeter\n-- | area = over2 Meter (*)\n-- | ```\n-- |\n-- | The above example also demonstrates that the return type is polymorphic\n-- | here too.\nover2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> a -> b)\n  -> t\n  -> t\n  -> s\nover2 _ = coerce\n\n-- | Much like `over2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\noverF2\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> f a -> g b)\n  -> f t\n  -> f t\n  -> g s\noverF2 _ = coerce\n\n-- | The opposite of `over2`: lowers a binary function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\nunder2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> t -> s)\n  -> a\n  -> a\n  -> b\nunder2 _ = coerce\n\n-- | Much like `under2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\nunderF2\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> f t -> g s)\n  -> f a\n  -> f a\n  -> g b\nunderF2 _ = coerce\n\n-- | Similar to the function from the `Traversable` class, but operating within\n-- | a newtype instead.\ntraverse\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (a -> f a)\n  -> t\n  -> f t\ntraverse _ = coerce\n\n-- | Similar to the function from the `Distributive` class, but operating within\n-- | a newtype instead.\ncollect\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (f a -> a)\n  -> f t\n  -> t\ncollect _ = coerce\n", "// jshint maxparams: 3\n\nexport const traverseArrayImpl = (function () {\n  function array1(a) {\n    return [a];\n  }\n\n  function array2(a) {\n    return function (b) {\n      return [a, b];\n    };\n  }\n\n  function array3(a) {\n    return function (b) {\n      return function (c) {\n        return [a, b, c];\n      };\n    };\n  }\n\n  function concat2(xs) {\n    return function (ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  return function (apply) {\n    return function (map) {\n      return function (pure) {\n        return function (f) {\n          return function (array) {\n            function go(bot, top) {\n              switch (top - bot) {\n              case 0: return pure([]);\n              case 1: return map(array1)(f(array[bot]));\n              case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));\n              case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));\n              default:\n                // This slightly tricky pivot selection aims to produce two\n                // even-length partitions where possible.\n                var pivot = bot + Math.floor((top - bot) / 4) * 2;\n                return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));\n              }\n            }\n            return go(0, array.length);\n          };\n        };\n      };\n    };\n  };\n})();\n", "-- | Types and operations for monadic parsing.\n-- |\n-- | Combinators are in the `Parsing.Combinators` module.\n-- |\n-- | Primitive parsers for `String` input streams are in the `Parsing.String`\n-- | module.\nmodule Parsing\n  ( Parser\n  , runParser\n  , ParserT(..)\n  , runParserT\n  , runParserT'\n  , ParseError(..)\n  , parseErrorMessage\n  , parseErrorPosition\n  , Position(..)\n  , initialPos\n  , consume\n  , position\n  , fail\n  , failWithPosition\n  , region\n  , liftMaybe\n  , liftEither\n  , liftExceptT\n  , ParseState(..)\n  , stateParserT\n  , getParserT\n  , hoistParserT\n  , mapParserT\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Apply (lift2)\nimport Control.Lazy (class Lazy)\nimport Control.Monad.Error.Class (class MonadError, class MonadThrow, catchError, throwError)\nimport Control.Monad.Except (ExceptT, runExceptT)\nimport Control.Monad.Reader.Class (class MonadAsk, class MonadReader, ask, local)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM)\nimport Control.Monad.State.Class (class MonadState, state)\nimport Control.Monad.Trans.Class (class MonadTrans, lift)\nimport Control.MonadPlus (class Alternative, class MonadPlus, class Plus)\nimport Data.Either (Either(..))\nimport Data.Function.Uncurried (Fn2, Fn5, mkFn2, mkFn3, mkFn5, runFn2, runFn3, runFn5)\nimport Data.Generic.Rep (class Generic)\nimport Data.Identity (Identity)\nimport Data.Lazy as Lazy\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (unwrap)\nimport Data.Show.Generic (genericShow)\nimport Data.Tuple (Tuple(..), fst)\n\n-- | A parsing error, consisting of an error message and\n-- | the position in the input stream at which the error occurred.\ndata ParseError = ParseError String Position\n\n-- | Get the `Message` from a `ParseError`\nparseErrorMessage :: ParseError -> String\nparseErrorMessage (ParseError msg _) = msg\n\n-- | Get the `Position` from a `ParseError`.\nparseErrorPosition :: ParseError -> Position\nparseErrorPosition (ParseError _ pos) = pos\n\ninstance showParseError :: Show ParseError where\n  show (ParseError msg pos) =\n    \"(ParseError \" <> show msg <> \" \" <> show pos <> \")\"\n\nderive instance eqParseError :: Eq ParseError\nderive instance ordParseError :: Ord ParseError\n\n-- | The internal state of the `ParserT s m` monad.\n-- |\n-- | Contains the remaining input and current position and the consumed flag.\n-- |\n-- | The consumed flag is used to implement the rule for `alt` that\n-- | - If the left parser fails *without consuming any input*, then backtrack and try the right parser.\n-- | - If the left parser fails and consumes input, then fail immediately.\ndata ParseState s = ParseState s Position Boolean\n-- ParseState constructor has three parameters,\n-- s: the remaining input\n-- Position: the current position\n-- Boolean: the consumed flag.\n--\n-- The consumed flag is used to implement the rule for `alt` that\n-- * If the left parser fails *without consuming any input*, then backtrack and try the right parser.\n-- * If the left parser fails and consumes input, then fail immediately.\n--\n-- https://hackage.haskell.org/package/parsec/docs/Text-Parsec.html#v:try\n--\n-- http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/\n\n-- | The `Parser s` monad with a monad transformer parameter `m`.\nnewtype ParserT s m a = ParserT\n  -- The parser is implemented using continuation-passing-style with uncurried\n  -- functions. In addition to the usual error and success continuations, there\n  -- are continuations for trampolining and lifting. Trampolining lets us retain\n  -- stack safety, and an explicit continuation for lifting lets us only pay\n  -- a transformer abstraction tax when it's actually used. Pure parsers which\n  -- never call `lift` pay no additional runtime cost. Additionally, this\n  -- approach lets us run a parser in terms of the base Monad's MonadRec instance,\n  -- so when lift _is_ used, it's still always stack safe.\n\n  -- When should the trampoline be invoked? Downstream combinators should not need\n  -- to worry about invoking the trampoline, as it's handled by the core instances\n  -- of the parser (the Monad and Alternative hierarchies). These instances invoke\n  -- the trampoline before calling continuations, so each step in the parser will\n  -- always progress in a fresh stack.\n  ( forall r\n     . Fn5\n         (ParseState s) -- Current state\n         ((Unit -> r) -> r) -- Trampoline\n         (m (Unit -> r) -> r) -- Lift\n         (Fn2 (ParseState s) ParseError r) -- Throw\n         (Fn2 (ParseState s) a r) -- Done/Success\n         r\n  )\n\n-- When we want to run a parser, continuations are reified as data\n-- constructors and processed in a tail-recursive loop.\ndata RunParser s m a\n  = More (Unit -> RunParser s m a)\n  | Lift (m (Unit -> RunParser s m a))\n  | Stop (ParseState s) (Either ParseError a)\n\n-- | `runParser` with a monad transfomer parameter `m`.\nrunParserT :: forall m s a. MonadRec m => s -> ParserT s m a -> m (Either ParseError a)\nrunParserT s p = fst <$> runParserT' initialState p\n  where\n  initialState :: ParseState s\n  initialState = ParseState s initialPos false\n\n-- | Run a parser and produce either an error or the result of the parser\n-- | along with the internal state of the parser when it finishes.\nrunParserT'\n  :: forall m s a\n   . MonadRec m\n  => ParseState s\n  -> ParserT s m a\n  -> m (Tuple (Either ParseError a) (ParseState s))\nrunParserT' state1 (ParserT k1) =\n  tailRecM go \\_ ->\n    runFn5 k1 state1 More Lift\n      (mkFn2 \\state2 err -> Stop state2 (Left err))\n      (mkFn2 \\state2 res -> Stop state2 (Right res))\n  where\n  go\n    :: (Unit -> RunParser s m a)\n    -> m (Step (Unit -> RunParser s m a) (Tuple (Either ParseError a) (ParseState s)))\n  go step = case step unit of\n    More next ->\n      go next\n    Lift m ->\n      Loop <$> m\n    Stop s res ->\n      pure $ Done (Tuple res s)\n\n-- | The `Parser s` monad, where `s` is the type of the input stream.\n-- |\n-- | A synonym for the `ParserT` monad transformer applied\n-- | to the `Identity` monad.\ntype Parser s = ParserT s Identity\n\n-- | Run a parser on an input stream `s` and produce either an error or the\n-- | result `a` of the parser.\nrunParser :: forall s a. s -> Parser s a -> Either ParseError a\nrunParser s = unwrap <<< runParserT s\n\nhoistParserT :: forall s m n a. (m ~> n) -> ParserT s m a -> ParserT s n a\nhoistParserT f (ParserT k) = ParserT\n  ( mkFn5 \\state1 more lift throw done ->\n      runFn5 k state1 more (lift <<< f) throw done\n  )\n\n-- | Change the underlying monad action `m` and result data type `a` in\n-- | a `ParserT s m` monad action.\nmapParserT\n  :: forall b n s a m\n   . MonadRec m\n  => Functor n\n  => ( m (Tuple (Either ParseError a) (ParseState s))\n       -> n (Tuple (Either ParseError b) (ParseState s))\n     )\n  -> ParserT s m a\n  -> ParserT s n b\nmapParserT f p = ParserT\n  ( mkFn5 \\state1 _ lift throw done ->\n      lift $ map\n        ( \\(Tuple res state2) _ ->\n            case res of\n              Left err ->\n                runFn2 throw state2 err\n              Right a ->\n                runFn2 done state2 a\n        )\n        (f (runParserT' state1 p))\n  )\n\ninstance Lazy (ParserT s m a) where\n  defer f = ParserT\n    ( mkFn5 \\state1 more lift throw done -> do\n        let (ParserT k1) = Lazy.force m\n        runFn5 k1 state1 more lift throw done\n    )\n    where\n    m = Lazy.defer f\n\ninstance Semigroup a => Semigroup (ParserT s m a) where\n  append = lift2 (<>)\n\ninstance Monoid a => Monoid (ParserT s m a) where\n  mempty = pure mempty\n\ninstance Functor (ParserT s m) where\n  map f (ParserT k) = ParserT\n    ( mkFn5 \\state1 more lift throw done ->\n        more \\_ ->\n          runFn5 k state1 more lift throw\n            ( mkFn2 \\state2 a ->\n                more \\_ ->\n                  runFn2 done state2 (f a)\n            )\n    )\n\ninstance Apply (ParserT s m) where\n  apply (ParserT k1) (ParserT k2) = ParserT\n    ( mkFn5 \\state1 more lift throw done ->\n        more \\_ ->\n          runFn5 k1 state1 more lift throw\n            ( mkFn2 \\state2 f ->\n                more \\_ ->\n                  runFn5 k2 state2 more lift throw\n                    ( mkFn2 \\state3 a ->\n                        more \\_ ->\n                          runFn2 done state3 (f a)\n                    )\n            )\n    )\n\ninstance Applicative (ParserT s m) where\n  pure a = ParserT\n    ( mkFn5 \\state1 _ _ _ done ->\n        runFn2 done state1 a\n    )\n\ninstance Bind (ParserT s m) where\n  bind (ParserT k1) next = ParserT\n    ( mkFn5 \\state1 more lift throw done ->\n        more \\_ ->\n          runFn5 k1 state1 more lift throw\n            ( mkFn2 \\state2 a ->\n                more \\_ -> do\n                  let (ParserT k2) = next a\n                  runFn5 k2 state2 more lift throw done\n            )\n    )\n\ninstance Monad (ParserT s m)\n\ninstance MonadRec (ParserT s m) where\n  tailRecM next initArg = ParserT\n    ( mkFn5 \\state1 more lift throw done -> do\n        let\n          -- In most cases, trampolining MonadRec is unnecessary since all the\n          -- core semantics are trampolined. But given the case where a loop might\n          -- otherwise be pure, we still want to guarantee stack usage so we use\n          -- a \"gas\" accumulator to avoid bouncing too much.\n          loop = mkFn3 \\state2 arg gas -> do\n            let (ParserT k1) = next arg\n            runFn5 k1 state2 more lift throw\n              ( mkFn2 \\state3 step -> case step of\n                  Loop nextArg ->\n                    if gas == 0 then\n                      more \\_ ->\n                        runFn3 loop state3 nextArg 30\n                    else\n                      runFn3 loop state3 nextArg (gas - 1)\n                  Done res ->\n                    runFn2 done state3 res\n              )\n        runFn3 loop state1 initArg 30\n    )\n\ninstance (MonadState t m) => MonadState t (ParserT s m) where\n  state k = lift (state k)\n\ninstance (MonadAsk r m) => MonadAsk r (ParserT s m) where\n  ask = lift ask\n\ninstance (MonadReader r m) => MonadReader r (ParserT s m) where\n  local f (ParserT k) = ParserT\n    ( mkFn5 \\state1 more lift throw done ->\n        runFn5 k state1 more (lift <<< local f) throw done\n    )\n\ninstance MonadThrow ParseError (ParserT s m) where\n  throwError err = ParserT\n    ( mkFn5 \\state1 _ _ throw _ ->\n        runFn2 throw state1 err\n    )\n\ninstance MonadError ParseError (ParserT s m) where\n  catchError (ParserT k1) next = ParserT\n    ( mkFn5 \\state1 more lift throw done ->\n        more \\_ ->\n          runFn5 k1 state1 more lift\n            ( mkFn2 \\state2 err -> do\n                let (ParserT k2) = next err\n                runFn5 k2 state2 more lift throw done\n            )\n            done\n    )\n\n-- | The alternative `Alt` instance provides the `alt` combinator `<|>`.\n-- |\n-- | The expression `p_left <|> p_right` will first try the `p_left` parser and if that fails\n-- | __and consumes no input__ then it will try the `p_right` parser.\n-- |\n-- | While we are parsing down the `p_left` branch we may reach a point where\n-- | we know this is the correct branch, but we cannot parse further. At\n-- | that point we want to fail the entire parse instead of trying the `p_right`\n-- | branch.\n-- |\n-- | For example, consider this `fileParser` which can parse either an HTML\n-- | file that begins with `<html>` or a shell script file that begins with `#!`.\n-- |\n-- | ```\n-- | fileParser =\n-- |   string \"<html>\" *> parseTheRestOfTheHtml\n-- |   <|>\n-- |   string \"#!\" *> parseTheRestOfTheScript\n-- | ```\n-- |\n-- | If we read a file from disk and run this `fileParser` on it and the\n-- | `string \"<html>\"` parser succeeds, then we know that the first branch\n-- | is the correct branch, so we want to commit to the first branch.\n-- | Even if the `parseTheRestOfTheHtml` parser fails\n-- | we don\u2019t want to try the second branch.\n-- |\n-- | To control the point at which we commit to the `p_left` branch\n-- | use the `try` combinator and the `lookAhead` combinator and\n-- | the `consume` function.\n-- |\n-- | The `alt` combinator works this way because it gives us good localized\n-- | error messages while also allowing an efficient implementation. See\n-- | [*Parsec: Direct Style Monadic Parser Combinators For The Real World*](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf)\n-- | section __2.3 Backtracking__.\ninstance Alt (ParserT s m) where\n  alt (ParserT k1) (ParserT k2) = ParserT\n    ( mkFn5 \\state1@(ParseState input pos _) more lift throw done ->\n        more \\_ ->\n          runFn5 k1 (ParseState input pos false) more lift\n            ( mkFn2 \\state2@(ParseState _ _ consumed) err ->\n                more \\_ ->\n                  if consumed then\n                    runFn2 throw state2 err\n                  else\n                    runFn5 k2 state1 more lift throw done\n            )\n            done\n    )\n\ninstance Plus (ParserT s m) where\n  empty = fail \"No alternative\"\n\ninstance Alternative (ParserT s m)\n\ninstance MonadPlus (ParserT s m)\n\ninstance MonadTrans (ParserT s) where\n  lift m = ParserT\n    ( mkFn5 \\state1 _ lift' _ done ->\n        lift' $ map (\\a _ -> runFn2 done state1 a) m\n    )\n\n-- | Query and modify the `ParserT` internal state.\n-- |\n-- | Like the `state` member of `MonadState`.\nstateParserT :: forall s m a. (ParseState s -> Tuple a (ParseState s)) -> ParserT s m a\nstateParserT k = ParserT\n  ( mkFn5 \\state1 _ _ _ done -> do\n      let (Tuple a state2) = k state1\n      runFn2 done state2 a\n  )\n\n-- | Query the `ParserT` internal state.\n-- |\n-- | Like the `get` member of `MonadState`.\ngetParserT :: forall s m. ParserT s m (ParseState s)\ngetParserT = ParserT\n  ( mkFn5 \\state1 _ _ _ done -> runFn2 done state1 state1\n  )\n\n-- | Set the consumed flag.\n-- |\n-- | Setting the consumed flag means that we're committed to this parsing branch\n-- | of an alternative (`<|>`), so that if this branch fails then we want to\n-- | fail the entire parse instead of trying the other alternative.\nconsume :: forall s m. ParserT s m Unit\nconsume = stateParserT \\(ParseState input pos _) -> Tuple unit (ParseState input pos true)\n\n-- | Returns the current position in the stream.\nposition :: forall s m. ParserT s m Position\nposition = stateParserT \\state1@(ParseState _ pos _) -> Tuple pos state1\n\n-- | Fail with a message.\nfail :: forall m s a. String -> ParserT s m a\nfail message = failWithPosition message =<< position\n\n-- | Fail with a message and a position.\nfailWithPosition :: forall m s a. String -> Position -> ParserT s m a\nfailWithPosition message pos = throwError (ParseError message pos)\n\n-- | Contextualize parsing failures inside a region. If a parsing failure\n-- | occurs, then the `ParseError` will be transformed by each containing\n-- | `region` as the parser backs out the call stack.\n-- |\n-- | For example, here\u2019s a helper function `inContext` which uses `region` to\n-- | add some string context to the error messages.\n-- |\n-- | ```\n-- | let\n-- |   inContext :: forall s m a. (String -> String) -> ParserT s m a -> ParserT s m a\n-- |   inContext context = region \\(ParseError message pos) ->\n-- |     ParseError (context message) pos\n-- |\n-- |   input = \"Tokyo thirty-nine million\"\n-- |\n-- | lmap (parseErrorHuman input 30) $ runParser input do\n-- |   inContext (\"Megacity list: \" <> _) do\n-- |     cityname <- inContext (\"city name: \" <> _) (takeWhile isLetter)\n-- |     skipSpaces\n-- |     population <- inContext (\"population: \" <> _) intDecimal\n-- |     pure $ Tuple cityname population\n-- | ```\n-- | ---\n-- | ```\n-- | Megacity list: population: Expected Int at position index:6 (line:1, column:7)\n-- |       \u25BC\n-- | Tokyo thirty-nine million\n-- | ```\nregion :: forall m s a. (ParseError -> ParseError) -> ParserT s m a -> ParserT s m a\nregion context p = catchError p $ \\err -> throwError $ context err\n\n-- | `Position` represents the position of the parser in the input stream.\n-- |\n-- | - `index` is the position offset since the start of the input. Starts\n-- |   at *0*.\n-- | - `line` is the current line in the input. Starts at *1*.\n-- | - `column` is the column of the next character in the current line that\n-- |   will be parsed. Starts at *1*.\nnewtype Position = Position\n  { index :: Int\n  , line :: Int\n  , column :: Int\n  }\n\nderive instance Generic Position _\ninstance Show Position where\n  show x = genericShow x\n\ninstance Eq Position where\n  eq (Position l) (Position r) = l.index == r.index\n\ninstance Ord Position where\n  compare (Position l) (Position r) = compare l.index r.index\n\n-- | The `Position` before any input has been parsed.\n-- |\n-- | `{ index: 0, line: 1, column: 1 }`\ninitialPos :: Position\ninitialPos = Position { index: 0, line: 1, column: 1 }\n\n-- | Lift a `Maybe a` computation into a `ParserT`, with a note for\n-- | the `ParseError` message in case of `Nothing`.\n-- |\n-- | Consumes no parsing input, does not change the parser state at all.\n-- | If the `Maybe` computation is `Nothing`, then this will `fail` in the\n-- | `ParserT` monad with the given error message `String` at the current input\n-- | `Position`.\n-- |\n-- | This is a \u201Cvalidation\u201D function, for when we want to produce some\n-- | data from the parsing input or fail at the current\n-- | parsing position if that\u2019s impossible.\n-- |\n-- | For example, parse an integer\n-- | [`BoundedEnum`](https://pursuit.purescript.org/packages/purescript-enums/docs/Data.Enum#t:BoundedEnum)\n-- | code and validate it by turning it\n-- | into a `MyEnum`. Use `tryRethrow` to position the parse error at the\n-- | beginning of the integer in the input `String` if the `toEnum` fails.\n-- |\n-- | ```\n-- | runParser \"3\" do\n-- |   myenum :: MyEnum <- tryRethrow do\n-- |     x <- intDecimal\n-- |     liftMaybe (\\_ -> \"Bad MyEnum \" <> show x) $ toEnum x\n-- | ```\nliftMaybe :: forall s m a. Monad m => (Unit -> String) -> Maybe a -> ParserT s m a\nliftMaybe message f = case f of\n  Nothing -> fail (message unit)\n  Just x -> pure x\n\n-- | Lift an `Either String a` computation into a `ParserT`.\n-- |\n-- | Consumes no parsing input, does not change the parser state at all.\n-- | If the `Either` computation is `Left String`, then this will `fail` in the\n-- | `ParserT` monad at the current input `Position`.\n-- |\n-- | This is a \u201Cvalidation\u201D function, for when we want to produce some\n-- | data from the parsing input or fail at the current\n-- | parsing position if that\u2019s impossible.\nliftEither :: forall s m a. Monad m => Either String a -> ParserT s m a\nliftEither f = case f of\n  Left err -> fail err\n  Right x -> pure x\n\n-- | Lift an `ExceptT String m a` computation into a `ParserT`.\n-- |\n-- | Consumes no parsing input, does not change the parser state at all.\n-- | If the `ExceptT` computation is `Left String`, then this will `fail` in the\n-- | `ParserT` monad at the current input `Position`.\n-- |\n-- | This is a \u201Cvalidation\u201D function, for when we want to produce some\n-- | data from the parsing input or fail at the current\n-- | parsing position if that\u2019s impossible.\nliftExceptT :: forall s m a. (Monad m) => ExceptT String m a -> ParserT s m a\nliftExceptT f = lift (runExceptT f) >>= case _ of\n  Left err -> fail err\n  Right x -> pure x\n", "-- | A \u201Cparser combinator\u201D is a function which takes some\n-- | parsers as arguments and returns a new parser.\n-- |\n-- | ## Combinators in other packages\n-- |\n-- | Many variations of well-known monadic and applicative combinators used for parsing are\n-- | defined in other PureScript packages. We list some of them here.\n-- |\n-- | If you use a combinator from some other package for parsing, keep in mind\n-- | this surprising truth about the __parsing__ package:\n-- | All other combinators used with this package will be stack-safe,\n-- | but usually the combinators with a `MonadRec` constraint will run faster.\n-- | So you should prefer `MonadRec` versions of combinators, but for reasons\n-- | of speed, not stack-safety.\n-- |\n-- | ### Data.Array\n-- |\n-- | The `many` and `many1` combinators in the __Parsing.Combinators.Array__\n-- | module are faster.\n-- |\n-- | * [Data.Array.many](https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array#v:many)\n-- | * [Data.Array.some](https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array#v:some)\n-- | * [Data.Array.NonEmpty.some](https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array.NonEmpty#v:some)\n-- |\n-- | ### Data.List\n-- |\n-- | The `many` and `many1` combinators in this package\n-- | are redeclarations of\n-- | the `manyRec` and `someRec` combinators in __Data.List__.\n-- |\n-- | ### Data.List.Lazy\n-- |\n-- | * [Data.List.Lazy.many](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List.Lazy#v:many)\n-- | * [Data.List.Lazy.some](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List.Lazy#v:some)\n-- |\n-- | ## Combinators in this package\n-- |\n-- | the __replicateA__ and __replicateM__ combinators are re-exported from\n-- | this module. `replicateA n p` or `replicateM n p`\n-- | will repeat parser `p` exactly `n` times. The `replicateA` combinator can\n-- | produce either an `Array` or a `List`.\nmodule Parsing.Combinators\n  ( try\n  , tryRethrow\n  , lookAhead\n  , choice\n  , between\n  , notFollowedBy\n  , option\n  , optionMaybe\n  , optional\n  , many\n  , many1\n  , manyTill\n  , manyTill_\n  , many1Till\n  , many1Till_\n  , manyIndex\n  , skipMany\n  , skipMany1\n  , sepBy\n  , sepBy1\n  , sepEndBy\n  , sepEndBy1\n  , endBy\n  , endBy1\n  , chainl\n  , chainl1\n  , chainr\n  , chainr1\n  , advance\n  , withErrorMessage\n  , (<?>)\n  , withLazyErrorMessage\n  , (<~?>)\n  , asErrorMessage\n  , (<??>)\n  , module Control.Plus\n  , module Data.Unfoldable\n  , module Data.Unfoldable1\n  , module Data.List.Lazy\n  ) where\n\nimport Prelude\n\nimport Control.Lazy (defer)\nimport Control.Monad.Error.Class (catchError, throwError)\nimport Control.Monad.Rec.Class (Step(..), tailRecM)\nimport Control.Plus (empty, (<|>), alt)\nimport Data.Foldable (class Foldable, foldl, foldr)\nimport Data.Function.Uncurried (mkFn2, mkFn5, runFn2, runFn5)\nimport Data.List (List(..), reverse, (:))\nimport Data.List as List\nimport Data.List.Lazy (replicateM)\nimport Data.List.NonEmpty (NonEmptyList, cons')\nimport Data.List.NonEmpty as NEL\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Tuple (Tuple(..))\nimport Data.Tuple.Nested (type (/\\), (/\\))\nimport Data.Unfoldable (replicateA)\nimport Data.Unfoldable1 (replicate1A)\nimport Parsing (ParseError(..), ParseState(..), ParserT(..), Position(..), fail, parseErrorMessage, parseErrorPosition, position)\n\n-- | Provide an error message in the case of failure.\nwithErrorMessage :: forall m s a. ParserT s m a -> String -> ParserT s m a\nwithErrorMessage p msg = p <|> fail (\"Expected \" <> msg)\n\ninfixl 4 withErrorMessage as <?>\n\n-- | Provide an error message in the case of failure, but lazily. This is handy\n-- | in cases where constructing the error message is expensive, so it's\n-- | preferable to defer it until an error actually happens.\n-- |\n-- |```purescript\n-- |parseBang :: Parser Char\n-- |parseBang = char '!' <~?> \\_ -> \"a bang\"\n-- |```\nwithLazyErrorMessage :: forall m s a. ParserT s m a -> (Unit -> String) -> ParserT s m a\nwithLazyErrorMessage p msg = p <|> defer \\_ -> fail (\"Expected \" <> msg unit)\n\ninfixl 4 withLazyErrorMessage as <~?>\n\n-- | Flipped `(<?>)`.\nasErrorMessage :: forall m s a. String -> ParserT s m a -> ParserT s m a\nasErrorMessage = flip (<?>)\n\ninfixr 3 asErrorMessage as <??>\n\n-- | Wrap a parser with opening and closing markers.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | parens = between (string \"(\") (string \")\")\n-- | ```\nbetween :: forall m s a open close. ParserT s m open -> ParserT s m close -> ParserT s m a -> ParserT s m a\nbetween open close p = open *> p <* close\n\n-- | Provide a default result in the case where a parser fails without consuming input.\noption :: forall m s a. a -> ParserT s m a -> ParserT s m a\noption a p = p <|> pure a\n\n-- | Optionally parse something, failing quietly.\n-- |\n-- | To optionally parse `p` and never fail: `optional (try p)`.\noptional :: forall m s a. ParserT s m a -> ParserT s m Unit\noptional p = void p <|> pure unit\n\n-- | pure `Nothing` in the case where a parser fails without consuming input.\noptionMaybe :: forall m s a. ParserT s m a -> ParserT s m (Maybe a)\noptionMaybe p = option Nothing (Just <$> p)\n\n-- | If the parser fails then backtrack the input stream to the unconsumed state.\n-- |\n-- | One use for this combinator is to ensure that the right parser of an\n-- | alternative will always be tried when the left parser fails.\n-- | ```\n-- | >>> runParser \"ac\" ((char 'a' *> char 'b') <|> (char 'a' *> char 'c'))\n-- | Left (ParseError \"Expected 'b'\" (Position { line: 1, column: 2 }))\n-- | ```\n-- | ---\n-- | ```\n-- | >>> runParser \"ac\" (try (char 'a' *> char 'b') <|> (char 'a' *> char 'c'))\n-- | Right 'c'\n-- | ```\ntry :: forall m s a. ParserT s m a -> ParserT s m a\ntry (ParserT k1) = ParserT\n  ( mkFn5 \\state1@(ParseState _ _ consumed) more lift throw done ->\n      runFn5 k1 state1 more lift\n        ( mkFn2 \\(ParseState input position _) err ->\n            runFn2 throw (ParseState input position consumed) err\n        )\n        done\n  )\n\n-- | If the parser fails then backtrack the input stream to the unconsumed state.\n-- |\n-- | Like `try`, but will reposition the error to the `try` point.\n-- |\n-- | ```\n-- | >>> runParser \"ac\" (try (char 'a' *> char 'b'))\n-- | Left (ParseError \"Expected 'b'\" (Position { index: 1, line: 1, column: 2 }))\n-- | ```\n-- | ---\n-- | ```\n-- | >>> runParser \"ac\" (tryRethrow (char 'a' *> char 'b'))\n-- | Left (ParseError \"Expected 'b'\" (Position { index: 0, line: 1, column: 1 }))\n-- | ```\ntryRethrow :: forall m s a. ParserT s m a -> ParserT s m a\ntryRethrow (ParserT k1) = ParserT\n  ( mkFn5 \\state1@(ParseState _ position consumed) more lift throw done ->\n      runFn5 k1 state1 more lift\n        ( mkFn2 \\(ParseState input' position' _) (ParseError err _) ->\n            runFn2 throw (ParseState input' position' consumed) (ParseError err position)\n        )\n        done\n  )\n\n-- | Parse a phrase, without modifying the consumed state or stream position.\nlookAhead :: forall s a m. ParserT s m a -> ParserT s m a\nlookAhead (ParserT k1) = ParserT\n  ( mkFn5 \\state1 more lift throw done ->\n      runFn5 k1 state1 more lift\n        (mkFn2 \\_ err -> runFn2 throw state1 err)\n        (mkFn2 \\_ res -> runFn2 done state1 res)\n  )\n\n-- | Match the phrase `p` as many times as possible.\n-- |\n-- | If `p` never consumes input when it\n-- | fails then `many p` will always succeed,\n-- | but may return an empty list.\nmany :: forall s m a. ParserT s m a -> ParserT s m (List a)\nmany = List.manyRec\n\n-- | Match the phrase `p` as many times as possible, at least once.\nmany1 :: forall m s a. ParserT s m a -> ParserT s m (NonEmptyList a)\nmany1 p = NEL.cons' <$> p <*> List.manyRec p\n\n-- | Parse phrases delimited by a separator.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | digit `sepBy` string \",\"\n-- | ```\nsepBy :: forall m s a sep. ParserT s m a -> ParserT s m sep -> ParserT s m (List a)\nsepBy p sep = map NEL.toList (sepBy1 p sep) <|> pure Nil\n\n-- | Parse phrases delimited by a separator, requiring at least one match.\nsepBy1 :: forall m s a sep. ParserT s m a -> ParserT s m sep -> ParserT s m (NonEmptyList a)\nsepBy1 p sep = do\n  a <- p\n  as <- List.manyRec $ sep *> p\n  pure (NEL.cons' a as)\n\n-- | Parse phrases delimited and optionally terminated by a separator.\nsepEndBy :: forall m s a sep. ParserT s m a -> ParserT s m sep -> ParserT s m (List a)\nsepEndBy p sep = map NEL.toList (sepEndBy1 p sep) <|> pure Nil\n\n-- | Parse phrases delimited and optionally terminated by a separator, requiring at least one match.\nsepEndBy1 :: forall m s a sep. ParserT s m a -> ParserT s m sep -> ParserT s m (NonEmptyList a)\nsepEndBy1 p sep = do\n  a <- p\n  (NEL.cons' a <$> tailRecM go Nil) <|> pure (NEL.singleton a)\n  where\n  go :: List a -> ParserT s m (Step (List a) (List a))\n  go acc = nextOne <|> done\n    where\n    nextOne = do\n      -- First make sure there's a separator.\n      _ <- sep\n      -- Then try the phrase and loop if it's there, or bail if it's not there.\n      (p <#> \\a -> Loop $ a : acc) <|> done\n\n    done = defer \\_ -> pure $ Done $ reverse acc\n\n-- | Parse phrases delimited and terminated by a separator, requiring at least one match.\nendBy1 :: forall m s a sep. ParserT s m a -> ParserT s m sep -> ParserT s m (NonEmptyList a)\nendBy1 p sep = many1 $ p <* sep\n\n-- | Parse phrases delimited and terminated by a separator.\nendBy :: forall m s a sep. ParserT s m a -> ParserT s m sep -> ParserT s m (List a)\nendBy p sep = List.manyRec $ p <* sep\n\n-- | `chainl p f` parses one or more occurrences of `p`, separated by operator `f`.\n-- |\n-- | Returns a value\n-- | obtained by a left-associative application of the functions returned by\n-- | `f` to the values returned by `p`. This combinator can be used to\n-- | eliminate left-recursion in expression grammars.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | chainl digit (string \"+\" $> add) 0\n-- | ```\nchainl :: forall m s a. ParserT s m a -> ParserT s m (a -> a -> a) -> a -> ParserT s m a\nchainl p f a = chainl1 p f <|> pure a\n\n-- | `chainl` requiring at least one match.\nchainl1 :: forall m s a. ParserT s m a -> ParserT s m (a -> a -> a) -> ParserT s m a\nchainl1 p f = do\n  a <- p\n  tailRecM go a\n  where\n  go :: a -> ParserT s m (Step a a)\n  go a =\n    ( do\n        op <- f\n        a' <- p\n        pure $ Loop $ op a a'\n    )\n      <|> pure (Done a)\n\n-- | `chainr p f` parses one or more occurrences of `p`, separated by operator `f`.\n-- |\n-- | Returns a value\n-- | obtained by a right-associative application of the functions returned by\n-- | `f` to the values returned by `p`. This combinator can be used to\n-- | eliminate right-recursion in expression grammars.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | chainr digit (string \"+\" $> add) 0\n-- | ```\nchainr :: forall m s a. ParserT s m a -> ParserT s m (a -> a -> a) -> a -> ParserT s m a\nchainr p f a = chainr1 p f <|> pure a\n\n-- | `chainr` requiring at least one match.\nchainr1 :: forall m s a. ParserT s m a -> ParserT s m (a -> a -> a) -> ParserT s m a\nchainr1 p f = do\n  a <- p\n  tailRecM go { last: a, init: Nil }\n  where\n  -- This looks scary at first glance, so I'm leaving a comment in a vain\n  -- attempt to explain how it works.\n  --\n  -- The loop state is a record {init, last}, where `last` is the last (i.e.\n  -- rightmost) `a` value that has been parsed so far, and `init` is a list of\n  -- (value + operator) pairs that have been parsed before that.\n  --\n  -- The very first value is parsed at top level, and it becomes the initial\n  -- value of `last`, while the initial value of `init` is just `Nil`,\n  -- indicating that no pairs of (value + operator) have been parsed yet.\n  --\n  -- At every step, we parse an operator and a value, and then the newly parsed\n  -- value becomes `last` (because, well, it's been parsed last), and the pair\n  -- of (previous last + operator) is prepended to `init`.\n  --\n  -- After we can no longer parse a pair of (value + operation), we're done. At\n  -- that point, we have a list of (value + operation) pairs in reverse order\n  -- (since we prepend each pair as we go) and the very last value. All that's\n  -- left is combine them all via `foldl`.\n  go\n    :: { init :: List (a /\\ (a -> a -> a)), last :: a }\n    -> ParserT s m\n         ( Step\n             { init :: List (a /\\ (a -> a -> a)), last :: a }\n             a\n         )\n  go { last, init } =\n    ( do\n        op <- f\n        a <- p\n        pure $ Loop { last: a, init: (last /\\ op) : init }\n    )\n      <|> defer \\_ -> pure (Done $ foldl apply last init)\n\n  apply :: a -> (a /\\ (a -> a -> a)) -> a\n  apply y (x /\\ op) = x `op` y\n\n-- | Parse one of a set of alternatives.\nchoice :: forall f m s a. Foldable f => f (ParserT s m a) -> ParserT s m a\nchoice = fromMaybe empty <<< foldr go Nothing\n  where\n  go p1 = case _ of\n    Nothing -> Just p1\n    Just p2 -> Just (p1 <|> p2)\n\n-- | Skip many instances of a phrase.\nskipMany :: forall s a m. ParserT s m a -> ParserT s m Unit\nskipMany p = skipMany1 p <|> pure unit\n\n-- | Skip at least one instance of a phrase.\nskipMany1 :: forall s a m. ParserT s m a -> ParserT s m Unit\nskipMany1 p = p *> tailRecM go unit\n  where\n  go _ = (p $> Loop unit) <|> pure (Done unit)\n\n-- | Fail if the parser succeeds.\n-- |\n-- | Will never consume input.\nnotFollowedBy :: forall s a m. ParserT s m a -> ParserT s m Unit\nnotFollowedBy p = try $ (try p *> fail \"Negated parser succeeded\") <|> pure unit\n\n-- | Parse many phrases until the terminator phrase matches.\nmanyTill :: forall s a m e. ParserT s m a -> ParserT s m e -> ParserT s m (List a)\nmanyTill p end = tailRecM go Nil\n  where\n  go :: List a -> ParserT s m (Step (List a) (List a))\n  go acc =\n    (end <#> \\_ -> Done $ reverse acc)\n      <|> (p <#> \\x -> Loop $ x : acc)\n\n-- | Parse at least one phrase until the terminator phrase matches.\nmany1Till :: forall s a m e. ParserT s m a -> ParserT s m e -> ParserT s m (NonEmptyList a)\nmany1Till p end = NEL.cons' <$> p <*> manyTill p end\n\n-- | Parse many phrases until the terminator phrase matches, requiring at least one match.\n-- | Returns the list of phrases and the terminator phrase.\nmany1Till_ :: forall s a m e. ParserT s m a -> ParserT s m e -> ParserT s m (Tuple (NonEmptyList a) e)\nmany1Till_ p end = do\n  x <- p\n  Tuple xs t <- manyTill_ p end\n  pure $ Tuple (cons' x xs) t\n\n-- | Parse many phrases until the terminator phrase matches.\n-- | Returns the list of phrases and the terminator phrase.\n-- |\n-- | #### Non-greedy repetition\n-- |\n-- | Use the __manyTill_ __ combinator\n-- | to do non-greedy repetition of a pattern `p`, like we would in Regex\n-- | by writing `p*?`.\n-- | To repeat pattern `p` non-greedily, write\n-- | `manyTill_ p q` where `q` is the entire rest of the parser.\n-- |\n-- | For example, this parse fails because `many` repeats the pattern `letter`\n-- | greedily.\n-- |\n-- | ```\n-- | runParser \"aab\" do\n-- |   a <- many letter\n-- |   b <- char 'b'\n-- |   pure (Tuple a b)\n-- | ```\n-- | ```\n-- | (ParseError \"Expected 'b'\" (Position { line: 1, column: 4 }))\n-- | ```\n-- |\n-- | To repeat pattern `letter` non-greedily, use `manyTill_`.\n-- |\n-- | ```\n-- | runParser \"aab\" do\n-- |   Tuple a b <- manyTill_ letter do\n-- |     char 'b'\n-- |   pure (Tuple a b)\n-- | ```\n-- | ```\n-- | (Tuple ('a' : 'a' : Nil) 'b')\n-- | ```\nmanyTill_ :: forall s a m e. ParserT s m a -> ParserT s m e -> ParserT s m (Tuple (List a) e)\nmanyTill_ p end = tailRecM go Nil\n  where\n  go :: List a -> ParserT s m (Step (List a) (Tuple (List a) e))\n  go xs = alt\n    do\n      t <- end\n      pure (Done (Tuple (reverse xs) t))\n    do\n      x <- p\n      pure (Loop (x : xs))\n\n-- | Parse the phrase as many times as possible, at least *N* times, but no\n-- | more than *M* times.\n-- | If the phrase can\u2019t parse as least *N* times then the whole\n-- | parser fails. If the phrase parses successfully *M* times then stop.\n-- | The current phrase index, starting at *0*, is passed to the phrase.\n-- |\n-- | Returns the list of parse results and the number of results.\n-- |\n-- | `manyIndex n n (\\_ -> p)` is equivalent to `replicateA n p`.\nmanyIndex :: forall s m a. Int -> Int -> (Int -> ParserT s m a) -> ParserT s m (Tuple Int (List a))\nmanyIndex from to p =\n  if from > to || from < 0 then\n    pure (Tuple 0 Nil)\n  else\n    tailRecM go (Tuple 0 Nil)\n  where\n  go (Tuple i xs) =\n    if i >= to then\n      pure (Done (Tuple i (reverse xs)))\n    else catchError\n      do\n        x <- p i\n        pure (Loop (Tuple (i + 1) (x : xs)))\n      \\e -> do\n        if i >= from then\n          pure (Done (Tuple i (reverse xs)))\n        else\n          throwError $ ParseError\n            (parseErrorMessage e <> \" (at least \" <> show from <> \", but only parsed \" <> show i <> \")\")\n            (parseErrorPosition e)\n\n-- | If the parser succeeds without advancing the input stream position,\n-- | then force the parser to fail.\n-- |\n-- | This combinator can be used to prevent infinite parser repetition.\n-- |\n-- | Does not depend on or effect the `consumed` flag which indicates whether\n-- | we are committed to this parsing branch.\nadvance :: forall s m a. ParserT s m a -> ParserT s m a\nadvance p = do\n  Position { index: index1 } <- position\n  x <- p\n  Position { index: index2 } <- position\n  if index2 > index1 then\n    pure x\n  else\n    fail \"Expected progress\"\n", "//------------------------------------------------------------------------------\n// Array creation --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const range = function (start) {\n  return function (end) {\n    var step = start > end ? -1 : 1;\n    var result = new Array(step * (end - start) + 1);\n    var i = start, n = 0;\n    while (i !== end) {\n      result[n++] = i;\n      i += step;\n    }\n    result[n] = i;\n    return result;\n  };\n};\n\nvar replicateFill = function (count) {\n  return function (value) {\n    if (count < 1) {\n      return [];\n    }\n    var result = new Array(count);\n    return result.fill(value);\n  };\n};\n\nvar replicatePolyfill = function (count) {\n  return function (value) {\n    var result = [];\n    var n = 0;\n    for (var i = 0; i < count; i++) {\n      result[n++] = value;\n    }\n    return result;\n  };\n};\n\n// In browsers that have Array.prototype.fill we use it, as it's faster.\nexport const replicate = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n\nexport const fromFoldableImpl = (function () {\n  function Cons(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n  var emptyList = {};\n\n  function curryCons(head) {\n    return function (tail) {\n      return new Cons(head, tail);\n    };\n  }\n\n  function listToArray(list) {\n    var result = [];\n    var count = 0;\n    var xs = list;\n    while (xs !== emptyList) {\n      result[count++] = xs.head;\n      xs = xs.tail;\n    }\n    return result;\n  }\n\n  return function (foldr) {\n    return function (xs) {\n      return listToArray(foldr(curryCons)(emptyList)(xs));\n    };\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Array size ------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const length = function (xs) {\n  return xs.length;\n};\n\n//------------------------------------------------------------------------------\n// Non-indexed reads -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unconsImpl = function (empty) {\n  return function (next) {\n    return function (xs) {\n      return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Indexed operations ----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const indexImpl = function (just) {\n  return function (nothing) {\n    return function (xs) {\n      return function (i) {\n        return i < 0 || i >= xs.length ? nothing :  just(xs[i]);\n      };\n    };\n  };\n};\n\nexport const findMapImpl = function (nothing) {\n  return function (isJust) {\n    return function (f) {\n      return function (xs) {\n        for (var i = 0; i < xs.length; i++) {\n          var result = f(xs[i]);\n          if (isJust(result)) return result;\n        }\n        return nothing;\n      };\n    };\n  };\n};\n\nexport const findIndexImpl = function (just) {\n  return function (nothing) {\n    return function (f) {\n      return function (xs) {\n        for (var i = 0, l = xs.length; i < l; i++) {\n          if (f(xs[i])) return just(i);\n        }\n        return nothing;\n      };\n    };\n  };\n};\n\nexport const findLastIndexImpl = function (just) {\n  return function (nothing) {\n    return function (f) {\n      return function (xs) {\n        for (var i = xs.length - 1; i >= 0; i--) {\n          if (f(xs[i])) return just(i);\n        }\n        return nothing;\n      };\n    };\n  };\n};\n\nexport const _insertAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (a) {\n        return function (l) {\n          if (i < 0 || i > l.length) return nothing;\n          var l1 = l.slice();\n          l1.splice(i, 0, a);\n          return just(l1);\n        };\n      };\n    };\n  };\n};\n\nexport const _deleteAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (l) {\n        if (i < 0 || i >= l.length) return nothing;\n        var l1 = l.slice();\n        l1.splice(i, 1);\n        return just(l1);\n      };\n    };\n  };\n};\n\nexport const _updateAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (a) {\n        return function (l) {\n          if (i < 0 || i >= l.length) return nothing;\n          var l1 = l.slice();\n          l1[i] = a;\n          return just(l1);\n        };\n      };\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Transformations -------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const reverse = function (l) {\n  return l.slice().reverse();\n};\n\nexport const concat = function (xss) {\n  if (xss.length <= 10000) {\n    // This method is faster, but it crashes on big arrays.\n    // So we use it when can and fallback to simple variant otherwise.\n    return Array.prototype.concat.apply([], xss);\n  }\n\n  var result = [];\n  for (var i = 0, l = xss.length; i < l; i++) {\n    var xs = xss[i];\n    for (var j = 0, m = xs.length; j < m; j++) {\n      result.push(xs[j]);\n    }\n  }\n  return result;\n};\n\nexport const filter = function (f) {\n  return function (xs) {\n    return xs.filter(f);\n  };\n};\n\nexport const partition = function (f) {\n  return function (xs) {\n    var yes = [];\n    var no  = [];\n    for (var i = 0; i < xs.length; i++) {\n      var x = xs[i];\n      if (f(x))\n        yes.push(x);\n      else\n        no.push(x);\n    }\n    return { yes: yes, no: no };\n  };\n};\n\nexport const scanl = function (f) {\n  return function (b) {\n    return function (xs) {\n      var len = xs.length;\n      var acc = b;\n      var out = new Array(len);\n      for (var i = 0; i < len; i++) {\n        acc = f(acc)(xs[i]);\n        out[i] = acc;\n      }\n      return out;\n    };\n  };\n};\n\nexport const scanr = function (f) {\n  return function (b) {\n    return function (xs) {\n      var len = xs.length;\n      var acc = b;\n      var out = new Array(len);\n      for (var i = len - 1; i >= 0; i--) {\n        acc = f(xs[i])(acc);\n        out[i] = acc;\n      }\n      return out;\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Sorting ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      }\n      else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare) {\n    return function (fromOrdering) {\n      return function (xs) {\n        var out;\n\n        if (xs.length < 2) return xs;\n\n        out = xs.slice(0);\n        mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);\n\n        return out;\n      };\n    };\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Subarrays -------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const slice = function (s) {\n  return function (e) {\n    return function (l) {\n      return l.slice(s, e);\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Zipping ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const zipWith = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var l = xs.length < ys.length ? xs.length : ys.length;\n      var result = new Array(l);\n      for (var i = 0; i < l; i++) {\n        result[i] = f(xs[i])(ys[i]);\n      }\n      return result;\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Folding ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const any = function (p) {\n  return function (xs) {\n    var len = xs.length;\n    for (var i = 0; i < len; i++) {\n      if (p(xs[i])) return true;\n    }\n    return false;\n  };\n};\n\nexport const all = function (p) {\n  return function (xs) {\n    var len = xs.length;\n    for (var i = 0; i < len; i++) {\n      if (!p(xs[i])) return false;\n    }\n    return true;\n  };\n};\n\n//------------------------------------------------------------------------------\n// Partial ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unsafeIndexImpl = function (xs) {\n  return function (n) {\n    return xs[n];\n  };\n};\n", "function newSTArray () {\n  return [];\n}\nexport { newSTArray as new };\n\nexport const peekImpl = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (xs) {\n        return function () {\n          return i >= 0 && i < xs.length ? just(xs[i]) : nothing;\n        };\n      };\n    };\n  };\n};\n\nexport const poke = function (i) {\n  return function (a) {\n    return function (xs) {\n      return function () {\n        var ret = i >= 0 && i < xs.length;\n        if (ret) xs[i] = a;\n        return ret;\n      };\n    };\n  };\n};\n\nexport const length = function (xs) {\n  return function () {\n    return xs.length;\n  };\n};\n\nexport const popImpl = function (just) {\n  return function (nothing) {\n    return function (xs) {\n      return function () {\n        return xs.length > 0 ? just(xs.pop()) : nothing;\n      };\n    };\n  };\n};\n\nexport const pushAll = function (as) {\n  return function (xs) {\n    return function () {\n      return xs.push.apply(xs, as);\n    };\n  };\n};\n\nexport const shiftImpl = function (just) {\n  return function (nothing) {\n    return function (xs) {\n      return function () {\n        return xs.length > 0 ? just(xs.shift()) : nothing;\n      };\n    };\n  };\n};\n\nexport const unshiftAll = function (as) {\n  return function (xs) {\n    return function () {\n      return xs.unshift.apply(xs, as);\n    };\n  };\n};\n\nexport const splice = function (i) {\n  return function (howMany) {\n    return function (bs) {\n      return function (xs) {\n        return function () {\n          return xs.splice.apply(xs, [i, howMany].concat(bs));\n        };\n      };\n    };\n  };\n};\n\nexport const unsafeFreeze = function (xs) {\n  return function () {\n    return xs;\n  };\n};\n\nexport const unsafeThaw = function (xs) {\n  return function () {\n    return xs;\n  };\n};\n\nfunction copyImpl(xs) {\n  return function () {\n    return xs.slice();\n  };\n}\n\nexport const freeze = copyImpl;\n\nexport const thaw = copyImpl;\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      }\n      else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare) {\n    return function (fromOrdering) {\n      return function (xs) {\n        return function () {\n          if (xs.length < 2) return xs;\n\n          mergeFromTo(compare, fromOrdering, xs, xs.slice(0), 0, xs.length);\n\n          return xs;\n        };\n      };\n    };\n  };\n})();\n\nexport const toAssocArray = function (xs) {\n  return function () {\n    var n = xs.length;\n    var as = new Array(n);\n    for (var i = 0; i < n; i++) as[i] = { value: xs[i], index: i };\n    return as;\n  };\n};\n", "-- | Helper functions for working with immutable Javascript arrays.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use `Data.List` or\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is useful when integrating with JavaScript libraries\n-- | which use arrays, but immutable arrays are not a practical data structure\n-- | for many use cases due to their poor asymptotics.\n-- |\n-- | In addition to the functions in this module, Arrays have a number of\n-- | useful instances:\n-- |\n-- | * `Functor`, which provides `map :: forall a b. (a -> b) -> Array a ->\n-- |   Array b`\n-- | * `Apply`, which provides `(<*>) :: forall a b. Array (a -> b) -> Array a\n-- |   -> Array b`. This function works a bit like a Cartesian product; the\n-- |   result array is constructed by applying each function in the first\n-- |   array to each value in the second, so that the result array ends up with\n-- |   a length equal to the product of the two arguments' lengths.\n-- | * `Bind`, which provides `(>>=) :: forall a b. (a -> Array b) -> Array a\n-- |   -> Array b` (this is the same as `concatMap`).\n-- | * `Semigroup`, which provides `(<>) :: forall a. Array a -> Array a ->\n-- |   Array a`, for concatenating arrays.\n-- | * `Foldable`, which provides a slew of functions for *folding* (also known\n-- |   as *reducing*) arrays down to one value. For example,\n-- |   `Data.Foldable.or` tests whether an array of `Boolean` values contains\n-- |   at least one `true` value.\n-- | * `Traversable`, which provides the PureScript version of a for-loop,\n-- |   allowing you to STAI.iterate over an array and accumulate effects.\n-- |\nmodule Data.Array\n  ( fromFoldable\n  , toUnfoldable\n  , singleton\n  , (..), range\n  , replicate\n  , some\n  , many\n\n  , null\n  , length\n\n  , (:), cons\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!), index\n  , elem\n  , notElem\n  , elemIndex\n  , elemLastIndex\n  , find\n  , findMap\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , updateAtIndices\n  , modifyAt\n  , modifyAtIndices\n  , alterAt\n\n  , intersperse\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , partition\n  , splitAt\n  , filterA\n  , mapMaybe\n  , catMaybes\n  , mapWithIndex\n  , foldl\n  , foldr\n  , foldMap\n  , fold\n  , intercalate\n  , transpose\n  , scanl\n  , scanr\n\n  , sort\n  , sortBy\n  , sortWith\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n\n  , nub\n  , nubEq\n  , nubBy\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n\n  , (\\\\), difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , any\n  , all\n\n  , foldM\n  , foldRecM\n\n  , unsafeIndex\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM2)\nimport Control.Monad.ST as ST\nimport Data.Array.NonEmpty.Internal (NonEmptyArray(..))\nimport Data.Array.ST as STA\nimport Data.Array.ST.Iterator as STAI\nimport Data.Foldable (class Foldable, traverse_)\nimport Data.Foldable as F\nimport Data.FunctorWithIndex as FWI\nimport Data.Maybe (Maybe(..), maybe, isJust, fromJust, isNothing)\nimport Data.Traversable (sequence, traverse)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Partial.Unsafe (unsafePartial)\n\n-- | Convert an `Array` into an `Unfoldable` structure.\ntoUnfoldable :: forall f. Unfoldable f => Array ~> f\ntoUnfoldable xs = unfoldr f 0\n  where\n  len = length xs\n  f i\n    | i < len   = Just (Tuple (unsafePartial (unsafeIndex xs i)) (i+1))\n    | otherwise = Nothing\n\n-- | Convert a `Foldable` structure into an `Array`.\n-- |\n-- | ```purescript\n-- | fromFoldable (Just 1) = [1]\n-- | fromFoldable (Nothing) = []\n-- | ```\n-- |\nfromFoldable :: forall f. Foldable f => f ~> Array\nfromFoldable = fromFoldableImpl F.foldr\n\nforeign import fromFoldableImpl\n  :: forall f a\n   . (forall b. (a -> b -> b) -> b -> f a -> b)\n  -> f a\n  -> Array a\n\n-- | Create an array of one element\n-- | ```purescript\n-- | singleton 2 = [2]\n-- | ```\nsingleton :: forall a. a -> Array a\nsingleton a = [a]\n\n-- | Create an array containing a range of integers, including both endpoints.\n-- | ```purescript\n-- | range 2 5 = [2, 3, 4, 5]\n-- | ```\nforeign import range :: Int -> Int -> Array Int\n\n-- | Create an array containing a value repeated the specified number of times.\n-- | ```purescript\n-- | replicate 2 \"Hi\" = [\"Hi\", \"Hi\"]\n-- | ```\nforeign import replicate :: forall a. Int -> a -> Array a\n\n-- | An infix synonym for `range`.\n-- | ```purescript\n-- | 2 .. 5 = [2, 3, 4, 5]\n-- | ```\ninfix 8 range as ..\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nsome v = (:) <$> v <*> defer (\\_ -> many v)\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nmany v = some v <|> pure []\n\n--------------------------------------------------------------------------------\n-- Array size ------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether an array is empty.\n-- | ```purescript\n-- | null [] = true\n-- | null [1, 2] = false\n-- | ```\nnull :: forall a. Array a -> Boolean\nnull xs = length xs == 0\n\n-- | Get the number of elements in an array.\n-- | ```purescript\n-- | length [\"Hello\", \"World\"] = 2\n-- | ```\nforeign import length :: forall a. Array a -> Int\n\n--------------------------------------------------------------------------------\n-- Extending arrays ------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Attaches an element to the front of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | cons 1 [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ncons :: forall a. a -> Array a -> Array a\ncons x xs = [x] <> xs\n\n-- | An infix alias for `cons`.\n-- |\n-- | ```purescript\n-- | 1 : [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ninfixr 6 cons as :\n\n-- | Append an element to the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | snoc [1, 2, 3] 4 = [1, 2, 3, 4]\n-- | ```\n-- |\nsnoc :: forall a. Array a -> a -> Array a\nsnoc xs x = ST.run (STA.withArray (STA.push x) xs)\n\n-- | Insert an element into a sorted array.\n-- |\n-- | ```purescript\n-- | insert 10 [1, 2, 20, 21] = [1, 2, 10, 20, 21]\n-- | ```\n-- |\ninsert :: forall a. Ord a => a -> Array a -> Array a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted array, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | ```purescript\n-- | invertCompare a b = invert $ compare a b\n-- |\n-- | insertBy invertCompare 10 [21, 20, 2, 1] = [21, 20, 10, 2, 1]\n-- | ```\n-- |\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> Array a -> Array a\ninsertBy cmp x ys =\n  let i = maybe 0 (_ + 1) (findLastIndex (\\y -> cmp x y == GT) ys)\n  in unsafePartial (fromJust (insertAt i x ys))\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | head [1, 2] = Just 1\n-- | head [] = Nothing\n-- | ```\n-- |\nhead :: forall a. Array a -> Maybe a\nhead xs = xs !! 0\n\n-- | Get the last element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | last [1, 2] = Just 2\n-- | last [] = Nothing\n-- | ```\n-- |\nlast :: forall a. Array a -> Maybe a\nlast xs = xs !! (length xs - 1)\n\n-- | Get all but the first element of an array, creating a new array, or\n-- | `Nothing` if the array is empty\n-- |\n-- | ```purescript\n-- | tail [1, 2, 3, 4] = Just [2, 3, 4]\n-- | tail [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ntail :: forall a. Array a -> Maybe (Array a)\ntail = unconsImpl (const Nothing) (\\_ xs -> Just xs)\n\n-- | Get all but the last element of an array, creating a new array, or\n-- | `Nothing` if the array is empty.\n-- |\n-- | ```purescript\n-- | init [1, 2, 3, 4] = Just [1, 2, 3]\n-- | init [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ninit :: forall a. Array a -> Maybe (Array a)\ninit xs\n  | null xs = Nothing\n  | otherwise = Just (slice zero (length xs - one) xs)\n\n-- | Break an array into its first element and remaining elements.\n-- |\n-- | Using `uncons` provides a way of writing code that would use cons patterns\n-- | in Haskell or pre-PureScript 0.7:\n-- | ``` purescript\n-- | f (x : xs) = something\n-- | f [] = somethingElse\n-- | ```\n-- | Becomes:\n-- | ``` purescript\n-- | f arr = case uncons arr of\n-- |   Just { head: x, tail: xs } -> something\n-- |   Nothing -> somethingElse\n-- | ```\nuncons :: forall a. Array a -> Maybe { head :: a, tail :: Array a }\nuncons = unconsImpl (const Nothing) \\x xs -> Just { head: x, tail: xs }\n\nforeign import unconsImpl\n  :: forall a b\n   . (Unit -> b)\n  -> (a -> Array a -> b)\n  -> Array a\n  -> b\n\n-- | Break an array into its last element and all preceding elements.\n-- |\n-- | ```purescript\n-- | unsnoc [1, 2, 3] = Just {init: [1, 2], last: 3}\n-- | unsnoc [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\nunsnoc :: forall a. Array a -> Maybe { init :: Array a, last :: a }\nunsnoc xs = { init: _, last: _ } <$> init xs <*> last xs\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | This function provides a safe way to read a value at a particular index\n-- | from an array.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | index sentence 0 = Just \"Hello\"\n-- | index sentence 7 = Nothing\n-- | ```\n-- |\nindex :: forall a. Array a -> Int -> Maybe a\nindex = indexImpl Just Nothing\n\nforeign import indexImpl\n  :: forall a\n   . (forall r. r -> Maybe r)\n  -> (forall r. Maybe r)\n  -> Array a\n  -> Int\n  -> Maybe a\n\n-- | An infix version of `index`.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | sentence !! 0 = Just \"Hello\"\n-- | sentence !! 7 = Nothing\n-- | ```\n-- |\ninfixl 8 index as !!\n\n-- | Returns true if the array has the given element.\nelem :: forall a. Eq a => a -> Array a -> Boolean\nelem a arr = isJust $ elemIndex a arr\n\n-- | Returns true if the array does not have the given element.\nnotElem :: forall a. Eq a => a -> Array a -> Boolean\nnotElem a arr = isNothing $ elemIndex a arr\n\n-- | Find the index of the first element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 0\n-- | elemIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemLastIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 2\n-- | elemLastIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemLastIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first element for which a predicate holds.\n-- |\n-- | ```purescript\n-- | find (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just \"bb\"\n-- | find (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\nfind :: forall a. (a -> Boolean) -> Array a -> Maybe a\nfind f xs = unsafePartial (unsafeIndex xs) <$> findIndex f xs\n\n-- | Find the first element in a data structure which satisfies\n-- | a predicate mapping.\nfindMap :: forall a b. (a -> Maybe b) -> Array a -> Maybe b\nfindMap = findMapImpl Nothing isJust\n\nforeign import findMapImpl\n  :: forall a b\n   . (forall c. Maybe c)\n  -> (forall c. Maybe c -> Boolean)\n  -> (a -> Maybe b)\n  -> Array a\n  -> Maybe b\n\n-- | Find the first index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 1\n-- | findIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindIndex = findIndexImpl Just Nothing\n\nforeign import findIndexImpl\n  :: forall a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> (a -> Boolean)\n  -> Array a\n  -> Maybe Int\n\n-- | Find the last index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findLastIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 2\n-- | findLastIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindLastIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindLastIndex = findLastIndexImpl Just Nothing\n\nforeign import findLastIndexImpl\n  :: forall a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> (a -> Boolean)\n  -> Array a\n  -> Maybe Int\n\n-- | Insert an element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | insertAt 2 \"!\" [\"Hello\", \"World\"] = Just [\"Hello\", \"World\", \"!\"]\n-- | insertAt 10 \"!\" [\"Hello\"] = Nothing\n-- | ```\n-- |\ninsertAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\ninsertAt = _insertAt Just Nothing\n\nforeign import _insertAt\n  :: forall a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> Int\n  -> a\n  -> Array a\n  -> Maybe (Array a)\n\n-- | Delete the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | deleteAt 0 [\"Hello\", \"World\"] = Just [\"World\"]\n-- | deleteAt 10 [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\ndeleteAt :: forall a. Int -> Array a -> Maybe (Array a)\ndeleteAt = _deleteAt Just Nothing\n\nforeign import _deleteAt\n  :: forall a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> Int\n  -> Array a\n  -> Maybe (Array a)\n\n-- | Change the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | updateAt 1 \"World\" [\"Hello\", \"Earth\"] = Just [\"Hello\", \"World\"]\n-- | updateAt 10 \"World\" [\"Hello\", \"Earth\"] = Nothing\n-- | ```\n-- |\nupdateAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\nupdateAt = _updateAt Just Nothing\n\nforeign import _updateAt\n  :: forall a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> Int\n  -> a\n  -> Array a\n  -> Maybe (Array a)\n\n-- | Apply a function to the element at the specified index, creating a new\n-- | array, or returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | modifyAt 1 toUpper [\"Hello\", \"World\"] = Just [\"Hello\", \"WORLD\"]\n-- | modifyAt 10 toUpper [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\nmodifyAt :: forall a. Int -> (a -> a) -> Array a -> Maybe (Array a)\nmodifyAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = updateAt i (f x) xs\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new array or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | ```purescript\n-- | alterAt 1 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\", \"World\"]\n-- |\n-- | alterAt 1 (stripSuffix $ Pattern \"!!!!!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\"]\n-- |\n-- | alterAt 10 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"] = Nothing\n-- | ```\n-- |\nalterAt :: forall a. Int -> (a -> Maybe a) -> Array a -> Maybe (Array a)\nalterAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = case f x of\n    Nothing -> deleteAt i xs\n    Just x' -> updateAt i x' xs\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Inserts the given element in between each element in the array. The array\n-- | must have two or more elements for this operation to take effect.\n-- |\n-- | ```purescript\n-- | intersperse \" \" [ \"a\", \"b\" ] == [ \"a\", \" \", \"b\" ]\n-- | intersperse 0 [ 1, 2, 3, 4, 5 ] == [ 1, 0, 2, 0, 3, 0, 4, 0, 5 ]\n-- | ```\n-- |\n-- | If the array has less than two elements, the input array is returned.\n-- | ```purescript\n-- | intersperse \" \" [] == []\n-- | intersperse \" \" [\"a\"] == [\"a\"]\n-- | ```\nintersperse :: forall a. a -> Array a -> Array a\nintersperse a arr = case length arr of\n  len | len < 2 -> arr\n      | otherwise -> STA.run do\n          let unsafeGetElem idx = unsafePartial (unsafeIndex arr idx)\n          out <- STA.new\n          _ <- STA.push (unsafeGetElem 0) out\n          ST.for 1 len \\idx -> do\n            _ <- STA.push a out\n            void (STA.push (unsafeGetElem idx) out)\n          pure out\n\n-- | Reverse an array, creating a new array.\n-- |\n-- | ```purescript\n-- | reverse [] = []\n-- | reverse [1, 2, 3] = [3, 2, 1]\n-- | ```\n-- |\nforeign import reverse :: forall a. Array a -> Array a\n\n-- | Flatten an array of arrays, creating a new array.\n-- |\n-- | ```purescript\n-- | concat [[1, 2, 3], [], [4, 5, 6]] = [1, 2, 3, 4, 5, 6]\n-- | ```\n-- |\nforeign import concat :: forall a. Array (Array a) -> Array a\n\n-- | Apply a function to each element in an array, and flatten the results\n-- | into a single, new array.\n-- |\n-- | ```purescript\n-- | concatMap (split $ Pattern \" \") [\"Hello World\", \"other thing\"]\n-- |    = [\"Hello\", \"World\", \"other\", \"thing\"]\n-- | ```\n-- |\nconcatMap :: forall a b. (a -> Array b) -> Array a -> Array b\nconcatMap = flip bind\n\n-- | Filter an array, keeping the elements which satisfy a predicate function,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | filter (_ > 0) [-1, 4, -5, 7] = [4, 7]\n-- | ```\n-- |\nforeign import filter :: forall a. (a -> Boolean) -> Array a -> Array a\n\n-- | Partition an array using a predicate function, creating a set of\n-- | new arrays. One for the values satisfying the predicate function\n-- | and one for values that don't.\n-- |\n-- | ```purescript\n-- | partition (_ > 0) [-1, 4, -5, 7] = { yes: [4, 7], no: [-1, -5] }\n-- | ```\n-- |\nforeign import partition\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { yes :: Array a, no :: Array a }\n\n-- | Splits an array into two subarrays, where `before` contains the elements\n-- | up to (but not including) the given index, and `after` contains the rest\n-- | of the elements, from that index on.\n-- |\n-- | ```purescript\n-- | >>> splitAt 3 [1, 2, 3, 4, 5]\n-- | { before: [1, 2, 3], after: [4, 5] }\n-- | ```\n-- |\n-- | Thus, the length of `(splitAt i arr).before` will equal either `i` or\n-- | `length arr`, if that is shorter. (Or if `i` is negative the length will\n-- | be 0.)\n-- |\n-- | ```purescript\n-- | splitAt 2 ([] :: Array Int) == { before: [], after: [] }\n-- | splitAt 3 [1, 2, 3, 4, 5] == { before: [1, 2, 3], after: [4, 5] }\n-- | ```\nsplitAt :: forall a. Int -> Array a -> { before :: Array a, after :: Array a }\nsplitAt i xs | i <= 0 = { before: [], after: xs }\nsplitAt i xs = { before: slice 0 i xs, after: slice i (length xs) xs }\n\n-- | Filter where the predicate returns a `Boolean` in some `Applicative`.\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. Array a -> Array (Array a)\n-- | powerSet = filterA (const [true, false])\n-- | ```\nfilterA :: forall a f. Applicative f => (a -> f Boolean) -> Array a -> f (Array a)\nfilterA p =\n  traverse (\\x -> Tuple x <$> p x)\n  >>> map (mapMaybe (\\(Tuple x b) -> if b then Just x else Nothing))\n\n-- | Apply a function to each element in an array, keeping only the results\n-- | which contain a value, creating a new array.\n-- |\n-- | ```purescript\n-- | parseEmail :: String -> Maybe Email\n-- | parseEmail = ...\n-- |\n-- | mapMaybe parseEmail [\"a.com\", \"hello@example.com\", \"--\"]\n-- |    = [Email {user: \"hello\", domain: \"example.com\"}]\n-- | ```\n-- |\nmapMaybe :: forall a b. (a -> Maybe b) -> Array a -> Array b\nmapMaybe f = concatMap (maybe [] singleton <<< f)\n\n-- | Filter an array of optional values, keeping only the elements which contain\n-- | a value, creating a new array.\n-- |\n-- | ```purescript\n-- | catMaybes [Nothing, Just 2, Nothing, Just 4] = [2, 4]\n-- | ```\n-- |\ncatMaybes :: forall a. Array (Maybe a) -> Array a\ncatMaybes = mapMaybe identity\n\n-- | Apply a function to each element in an array, supplying a generated\n-- | zero-based index integer along with the element, creating an array\n-- | with the new elements.\n-- |\n-- | ```purescript\n-- | prefixIndex index element = show index <> element\n-- |\n-- | mapWithIndex prefixIndex [\"Hello\", \"World\"] = [\"0Hello\", \"1World\"]\n-- | ```\n-- |\nmapWithIndex :: forall a b. (Int -> a -> b) -> Array a -> Array b\nmapWithIndex = FWI.mapWithIndex\n\n-- | Change the elements at the specified indices in index/value pairs.\n-- | Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | updates = [Tuple 0 \"Hi\", Tuple 2 \".\" , Tuple 10 \"foobar\"]\n-- |\n-- | updateAtIndices updates [\"Hello\", \"World\", \"!\"] = [\"Hi\", \"World\", \".\"]\n-- | ```\n-- |\nupdateAtIndices :: forall t a. Foldable t => t (Tuple Int a) -> Array a -> Array a\nupdateAtIndices us xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\(Tuple i a) -> STA.poke i a res) us) xs)\n\n-- | Apply a function to the element at the specified indices,\n-- | creating a new array. Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | indices = [1, 3]\n-- | modifyAtIndices indices toUpper [\"Hello\", \"World\", \"and\", \"others\"]\n-- |    = [\"Hello\", \"WORLD\", \"and\", \"OTHERS\"]\n-- | ```\n-- |\nmodifyAtIndices :: forall t a. Foldable t => t Int -> (a -> a) -> Array a -> Array a\nmodifyAtIndices is f xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\i -> STA.modify i f res) is) xs)\n\nfoldl :: forall a b. (b -> a -> b) -> b -> Array a -> b\nfoldl = F.foldl\n\nfoldr :: forall a b. (a -> b -> b) -> b -> Array a -> b\nfoldr = F.foldr\n\nfoldMap :: forall a m. Monoid m => (a -> m) -> Array a -> m\nfoldMap = F.foldMap\n\nfold :: forall m. Monoid m => Array m -> m\nfold = F.fold\n\nintercalate :: forall a. Monoid a => a -> Array a -> a\nintercalate = F.intercalate\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- | ```purescript\n-- | transpose \n-- |   [ [1, 2, 3]\n-- |   , [4, 5, 6]\n-- |   ] == \n-- |   [ [1, 4]\n-- |   , [2, 5]\n-- |   , [3, 6]\n-- |   ]\n-- | ```\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- | ```purescript\n-- | transpose \n-- |   [ [10, 11]\n-- |   , [20]\n-- |   , [30, 31, 32]\n-- |   ] == \n-- |   [ [10, 20, 30]\n-- |   , [11, 31]\n-- |   , [32]\n-- |   ]\n-- | ```\ntranspose :: forall a. Array (Array a) -> Array (Array a)\ntranspose xs = go 0 []\n  where\n  go :: Int -> Array (Array a) -> Array (Array a)\n  go idx allArrays = case buildNext idx of\n    Nothing -> allArrays\n    Just next -> go (idx + 1) (snoc allArrays next)  \n   \n  buildNext :: Int -> Maybe (Array a)\n  buildNext idx = do\n    xs # flip foldl Nothing \\acc nextArr -> do\n      maybe acc (\\el -> Just $ maybe [el] (flip snoc el) acc) $ index nextArr idx\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanl`).\n-- |\n-- | ```\n-- | scanl (+) 0  [1,2,3] = [1,3,6]\n-- | scanl (-) 10 [1,2,3] = [9,7,4]\n-- | ```\nforeign import scanl :: forall a b. (b -> a -> b) -> b -> Array a -> Array b\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```\n-- | scanr (+) 0 [1,2,3] = [6,5,3]\n-- | scanr (flip (-)) 10 [1,2,3] = [4,5,7]\n-- | ```\nforeign import scanr :: forall a b. (a -> b -> b) -> b -> Array a -> Array b\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an array in increasing order, creating a new array.\n-- | Sorting is stable: the order of equal elements is preserved.\n-- |\n-- | ```purescript\n-- | sort [2, -3, 1] = [-3, 1, 2]\n-- | ```\n-- |\nsort :: forall a. Ord a => Array a -> Array a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | compared using the specified partial ordering, creating a new array.\n-- | Sorting is stable: the order of elements is preserved if they are equal\n-- | according to the specified partial ordering.\n-- |\n-- | ```purescript\n-- | compareLength a b = compare (length a) (length b)\n-- | sortBy compareLength [[1, 2, 3], [7, 9], [-2]] = [[-2],[7,9],[1,2,3]]\n-- | ```\n-- |\nsortBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nsortBy comp = sortByImpl comp case _ of\n  GT -> 1\n  EQ -> 0\n  LT -> -1\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | sorted based on a projection. Sorting is stable: the order of elements is\n-- | preserved if they are equal according to the projection.\n-- |\n-- | ```purescript\n-- | sortWith (_.age) [{name: \"Alice\", age: 42}, {name: \"Bob\", age: 21}]\n-- |    = [{name: \"Bob\", age: 21}, {name: \"Alice\", age: 42}]\n-- | ```\n-- |\nsortWith :: forall a b. Ord b => (a -> b) -> Array a -> Array a\nsortWith f = sortBy (comparing f)\n\nforeign import sortByImpl :: forall a. (a -> a -> Ordering) -> (Ordering -> Int) -> Array a -> Array a\n\n--------------------------------------------------------------------------------\n-- Subarrays -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Extract a subarray by a start and end index.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- | slice 1 3 letters = [\"b\", \"c\"]\n-- | slice 5 7 letters = []\n-- | slice 4 1 letters = []\n-- | ```\n-- |\nforeign import slice :: forall a. Int -> Int -> Array a -> Array a\n\n-- | Keep only a number of elements from the start of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | take 2 letters = [\"a\", \"b\"]\n-- | take 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntake :: forall a. Int -> Array a -> Array a\ntake n xs = if n < 1 then [] else slice 0 n xs\n\n-- | Keep only a number of elements from the end of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | takeEnd 2 letters = [\"b\", \"c\"]\n-- | takeEnd 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntakeEnd :: forall a. Int -> Array a -> Array a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Calculate the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | takeWhile (_ > 0) [4, 1, 0, -4, 5] = [4, 1]\n-- | takeWhile (_ > 0) [-1, 4] = []\n-- | ```\n-- |\ntakeWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ntakeWhile p xs = (span p xs).init\n\n-- | Drop a number of elements from the start of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | drop 2 letters = [\"c\", \"d\"]\n-- | drop 10 letters = []\n-- | ```\n-- |\ndrop :: forall a. Int -> Array a -> Array a\ndrop n xs = if n < 1 then xs else slice n (length xs) xs\n\n-- | Drop a number of elements from the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | dropEnd 2 letters = [\"a\", \"b\"]\n-- | dropEnd 10 letters = []\n-- | ```\n-- |\ndropEnd :: forall a. Int -> Array a -> Array a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Remove the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | dropWhile (_ < 0) [-3, -1, 0, 4, -6] = [0, 4, -6]\n-- | ```\n-- |\ndropWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ndropWhile p xs = (span p xs).rest\n\n-- | Split an array into two parts:\n-- |\n-- | 1. the longest initial subarray for which all elements satisfy the\n-- |    specified predicate\n-- | 2. the remaining elements\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) [1,3,2,4,5] == { init: [1,3], rest: [2,4,5] }\n-- | ```\n-- |\n-- | Running time: `O(n)`.\nspan\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { init :: Array a, rest :: Array a }\nspan p arr =\n  case breakIndex of\n    Just 0 ->\n      { init: [], rest: arr }\n    Just i ->\n      { init: slice 0 i arr, rest: slice i (length arr) arr }\n    Nothing ->\n      { init: arr, rest: [] }\n  where\n  breakIndex = go 0\n  go i =\n    -- This looks like a good opportunity to use the Monad Maybe instance,\n    -- but it's important to write out an explicit case expression here in\n    -- order to ensure that TCO is triggered.\n    case index arr i of\n      Just x -> if p x then go (i + 1) else Just i\n      Nothing -> Nothing\n\n-- | Group equal, consecutive elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | group [1, 1, 2, 2, 1] == [NonEmptyArray [1, 1], NonEmptyArray [2, 2], NonEmptyArray [1]]\n-- | ```\ngroup :: forall a. Eq a => Array a -> Array (NonEmptyArray a)\ngroup xs = groupBy eq xs\n\n-- | Group equal elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | groupAll [1, 1, 2, 2, 1] == [NonEmptyArray [1, 1, 1], NonEmptyArray [2, 2]]\n-- | ```\ngroupAll :: forall a. Ord a => Array a -> Array (NonEmptyArray a)\ngroupAll = groupAllBy compare\n\n-- | Group equal, consecutive elements of an array into arrays, using the\n-- | specified equivalence relation to determine equality.\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmptyArray [1, 3], NonEmptyArray [2], NonEmptyArray [4], NonEmptyArray [3, 3]]\n-- | ```\n-- |\ngroupBy :: forall a. (a -> a -> Boolean) -> Array a -> Array (NonEmptyArray a)\ngroupBy op xs =\n  ST.run do\n    result <- STA.new\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\x -> void do\n      sub <- STA.new\n      _ <- STA.push x sub\n      STAI.pushWhile (op x) iter sub\n      grp <- STA.unsafeFreeze sub\n      STA.push (NonEmptyArray grp) result\n    STA.unsafeFreeze result\n\n-- | Group equal elements of an array into arrays, using the specified\n-- | comparison function to determine equality.\n-- |\n-- | ```purescript\n-- | groupAllBy (comparing Down) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmptyArray [4], NonEmptyArray [3, 3, 3], NonEmptyArray [2], NonEmptyArray [1]]\n-- | ```\n-- |\ngroupAllBy :: forall a. (a -> a -> Ordering) -> Array a -> Array (NonEmptyArray a)\ngroupAllBy cmp = groupBy (\\x y -> cmp x y == EQ) <<< sortBy cmp\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | ```purescript\n-- | nub [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnub :: forall a. Ord a => Array a -> Array a\nnub = nubBy compare\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnubEq :: forall a. Eq a => Array a -> Array a\nnubEq = nubByEq eq\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified ordering, creating a new array.\n-- |\n-- | ```purescript\n-- | nubBy compare [1, 3, 4, 2, 2, 1] == [1, 3, 4, 2]\n-- | ```\n-- |\nnubBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nnubBy comp xs = case head indexedAndSorted of\n  Nothing -> []\n  Just x -> map snd $ sortWith fst $ ST.run do\n     -- TODO: use NonEmptyArrays here to avoid partial functions\n     result <- STA.unsafeThaw $ singleton x\n     ST.foreach indexedAndSorted \\pair@(Tuple _ x') -> do\n       lst <- snd <<< unsafePartial (fromJust <<< last) <$> STA.unsafeFreeze result\n       when (comp lst x' /= EQ) $ void $ STA.push pair result\n     STA.unsafeFreeze result\n  where\n  indexedAndSorted :: Array (Tuple Int a)\n  indexedAndSorted = sortBy (\\x y -> comp (snd x) (snd y))\n                            (mapWithIndex Tuple xs)\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified equivalence relation, creating a new array.\n-- |\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | relation.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | nubByEq mod3eq [1, 3, 4, 5, 6] = [1, 3, 5]\n-- | ```\n-- |\nnubByEq :: forall a. (a -> a -> Boolean) -> Array a -> Array a\nnubByEq eq xs = ST.run do\n  arr <- STA.new\n  ST.foreach xs \\x -> do\n    e <- not <<< any (_ `eq` x) <$> (STA.unsafeFreeze arr)\n    when e $ void $ STA.push x arr\n  STA.unsafeFreeze arr\n\n-- | Calculate the union of two arrays. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | Running time: `O(n^2)`\n-- |\n-- | ```purescript\n-- | union [1, 2, 1, 1] [3, 3, 3, 4] = [1, 2, 1, 1, 3, 4]\n-- | ```\n-- |\nunion :: forall a. Eq a => Array a -> Array a -> Array a\nunion = unionBy (==)\n\n-- | Calculate the union of two arrays, using the specified function to\n-- | determine equality of elements. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | unionBy mod3eq [1, 5, 1, 2] [3, 4, 3, 3] = [1, 5, 1, 2, 3]\n-- | ```\n-- |\nunionBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first element of an array which is equal to the specified value,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | delete 7 [1, 7, 3, 7] = [1, 3, 7]\n-- | delete 7 [1, 2, 3] = [1, 2, 3]\n-- | ```\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> Array a -> Array a\ndelete = deleteBy eq\n\n-- | Delete the first element of an array which matches the specified value,\n-- | under the equivalence relation provided in the first argument, creating a\n-- | new array.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | deleteBy mod3eq 6 [1, 3, 4, 3] = [1, 4, 3]\n-- | ```\n-- |\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> Array a -> Array a\ndeleteBy _  _ [] = []\ndeleteBy eq x ys = maybe ys (\\i -> unsafePartial $ fromJust (deleteAt i ys)) (findIndex (eq x) ys)\n\n-- | Delete the first occurrence of each element in the second array from the\n-- | first array, creating a new array.\n-- |\n-- | ```purescript\n-- | difference [2, 1] [2, 3] = [1]\n-- | ```\n-- |\n-- | Running time: `O(n*m)`, where n is the length of the first array, and m is\n-- | the length of the second.\ndifference :: forall a. Eq a => Array a -> Array a -> Array a\ndifference = foldr delete\n\ninfix 5 difference as \\\\\n\n-- | Calculate the intersection of two arrays, creating a new array. Note that\n-- | duplicates in the first array are preserved while duplicates in the second\n-- | array are removed.\n-- |\n-- | ```purescript\n-- | intersect [1, 1, 2] [2, 2, 1] = [1, 1, 2]\n-- | ```\n-- |\nintersect :: forall a. Eq a => Array a -> Array a -> Array a\nintersect = intersectBy eq\n\n-- | Calculate the intersection of two arrays, using the specified equivalence\n-- | relation to compare elements, creating a new array. Note that duplicates\n-- | in the first array are preserved while duplicates in the second array are\n-- | removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | intersectBy mod3eq [1, 2, 3] [4, 6, 7] = [1, 3]\n-- | ```\n-- |\nintersectBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nintersectBy eq xs ys = filter (\\x -> isJust (findIndex (eq x) ys)) xs\n\n-- | Apply a function to pairs of elements at the same index in two arrays,\n-- | collecting the results in a new array.\n-- |\n-- | If one array is longer, elements will be discarded from the longer array.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) [1, 2, 3] [4, 5, 6, 7] == [4, 10, 18]\n-- | ```\nforeign import zipWith\n  :: forall a b c\n   . (a -> b -> c)\n  -> Array a\n  -> Array b\n  -> Array c\n\n-- | A generalization of `zipWith` which accumulates results in some\n-- | `Applicative` functor.\n-- |\n-- | ```purescript\n-- | sndChars = zipWithA (\\a b -> charAt 2 (a <> b))\n-- | sndChars [\"a\", \"b\"] [\"A\", \"B\"] = Nothing -- since \"aA\" has no 3rd char\n-- | sndChars [\"aa\", \"b\"] [\"AA\", \"BBB\"] = Just ['A', 'B']\n-- | ```\n-- |\nzipWithA\n  :: forall m a b c\n   . Applicative m\n  => (a -> b -> m c)\n  -> Array a\n  -> Array b\n  -> m (Array c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Takes two arrays and returns an array of corresponding pairs.\n-- | If one input array is short, excess elements of the longer array are\n-- | discarded.\n-- |\n-- | ```purescript\n-- | zip [1, 2, 3] [\"a\", \"b\"] = [Tuple 1 \"a\", Tuple 2 \"b\"]\n-- | ```\n-- |\nzip :: forall a b. Array a -> Array b -> Array (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms an array of pairs into an array of first components and an\n-- | array of second components.\n-- |\n-- | ```purescript\n-- | unzip [Tuple 1 \"a\", Tuple 2 \"b\"] = Tuple [1, 2] [\"a\", \"b\"]\n-- | ```\n-- |\nunzip :: forall a b. Array (Tuple a b) -> Tuple (Array a) (Array b)\nunzip xs =\n  ST.run do\n    fsts <- STA.new\n    snds <- STA.new\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\(Tuple fst snd) -> do\n      void $ STA.push fst fsts\n      void $ STA.push snd snds\n    fsts' <- STA.unsafeFreeze fsts\n    snds' <- STA.unsafeFreeze snds\n    pure $ Tuple fsts' snds'\n\n-- | Returns true if at least one array element satisfies the given predicate,\n-- | iterating the array only as necessary and stopping as soon as the predicate\n-- | yields true.\n-- |\n-- | ```purescript\n-- | any (_ > 0) [] = False\n-- | any (_ > 0) [-1, 0, 1] = True\n-- | any (_ > 0) [-1, -2, -3] = False\n-- | ```\nforeign import any :: forall a. (a -> Boolean) -> Array a -> Boolean\n\n-- | Returns true if all the array elements satisfy the given predicate.\n-- | iterating the array only as necessary and stopping as soon as the predicate\n-- | yields false.\n-- |\n-- | ```purescript\n-- | all (_ > 0) [] = True\n-- | all (_ > 0) [1, 2, 3] = True\n-- | all (_ > 0) [-1, -2, -3] = False\n-- | ```\nforeign import all :: forall a. (a -> Boolean) -> Array a -> Boolean\n\n-- | Perform a fold using a monadic step function.\n-- |\n-- | ```purescript\n-- | foldM (\\x y -> Just (x + y)) 0 [1, 4] = Just 5\n-- | ```\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> Array a -> m b\nfoldM f b = unconsImpl (\\_ -> pure b) (\\a as -> f b a >>= \\b' -> foldM f b' as)\n\nfoldRecM :: forall m a b. MonadRec m => (b -> a -> m b) -> b -> Array a -> m b\nfoldRecM f b array = tailRecM2 go b 0\n  where\n  go res i\n    | i >= length array = pure (Done res)\n    | otherwise = do\n        res' <- f res (unsafePartial (unsafeIndex array i))\n        pure (Loop { a: res', b: i + 1 })\n\n-- | Find the element of an array at the specified index.\n-- |\n-- | ```purescript\n-- | unsafePartial $ unsafeIndex [\"a\", \"b\", \"c\"] 1 = \"b\"\n-- | ```\n-- |\n-- | Using `unsafeIndex` with an out-of-range index will not immediately raise a runtime error.\n-- | Instead, the result will be undefined. Most attempts to subsequently use the result will\n-- | cause a runtime error, of course, but this is not guaranteed, and is dependent on the backend;\n-- | some programs will continue to run as if nothing is wrong. For example, in the JavaScript backend,\n-- | the expression `unsafePartial (unsafeIndex [true] 1)` has type `Boolean`;\n-- | since this expression evaluates to `undefined`, attempting to use it in an `if` statement will cause\n-- | the else branch to be taken.\nunsafeIndex :: forall a. Partial => Array a -> Int -> a\nunsafeIndex = unsafeIndexImpl\n\nforeign import unsafeIndexImpl :: forall a. Array a -> Int -> a\n", "export const foldr1Impl = function (f) {\n  return function (xs) {\n    var acc = xs[xs.length - 1];\n    for (var i = xs.length - 2; i >= 0; i--) {\n      acc = f(xs[i])(acc);\n    }\n    return acc;\n  };\n};\n\nexport const foldl1Impl = function (f) {\n  return function (xs) {\n    var acc = xs[0];\n    var len = xs.length;\n    for (var i = 1; i < len; i++) {\n      acc = f(acc)(xs[i]);\n    }\n    return acc;\n  };\n};\n\nexport const traverse1Impl = function () {\n  function Cont(fn) {\n    this.fn = fn;\n  }\n\n  var emptyList = {};\n\n  var ConsCell = function (head, tail) {\n    this.head = head;\n    this.tail = tail;\n  };\n\n  function finalCell(head) {\n    return new ConsCell(head, emptyList);\n  }\n\n  function consList(x) {\n    return function (xs) {\n      return new ConsCell(x, xs);\n    };\n  }\n\n  function listToArray(list) {\n    var arr = [];\n    var xs = list;\n    while (xs !== emptyList) {\n      arr.push(xs.head);\n      xs = xs.tail;\n    }\n    return arr;\n  }\n\n  return function (apply) {\n    return function (map) {\n      return function (f) {\n        var buildFrom = function (x, ys) {\n          return apply(map(consList)(f(x)))(ys);\n        };\n\n        var go = function (acc, currentLen, xs) {\n          if (currentLen === 0) {\n            return acc;\n          } else {\n            var last = xs[currentLen - 1];\n            return new Cont(function () {\n              var built = go(buildFrom(last, acc), currentLen - 1, xs);\n              return built;\n            });\n          }\n        };\n\n        return function (array) {\n          var acc = map(finalCell)(f(array[array.length - 1]));\n          var result = go(acc, array.length - 1, array);\n          while (result instanceof Cont) {\n            result = result.fn();\n          }\n\n          return map(listToArray)(result);\n        };\n      };\n    };\n  };\n}();\n", "export function toCharCode(c) {\n  return c.charCodeAt(0);\n}\n\nexport function fromCharCode(c) {\n  return String.fromCharCode(c);\n}\n", "module Data.Enum\n  ( class Enum, succ, pred\n  , class BoundedEnum, cardinality, toEnum, fromEnum\n  , toEnumWithDefaults\n  , Cardinality(..)\n  , enumFromTo\n  , enumFromThenTo\n  , upFrom\n  , upFromIncluding\n  , downFrom\n  , downFromIncluding\n  , defaultSucc\n  , defaultPred\n  , defaultCardinality\n  , defaultToEnum\n  , defaultFromEnum\n  ) where\n\nimport Prelude\n\nimport Control.MonadPlus (guard)\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..), maybe, fromJust)\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable, singleton, unfoldr)\nimport Data.Unfoldable1 (class Unfoldable1, unfoldr1)\nimport Partial.Unsafe (unsafePartial)\n\n-- | Type class for enumerations.\n-- |\n-- | Laws:\n-- | - Successor: `all (a < _) (succ a)`\n-- | - Predecessor: `all (_ < a) (pred a)`\n-- | - Succ retracts pred: `pred >=> succ >=> pred = pred`\n-- | - Pred retracts succ: `succ >=> pred >=> succ = succ`\n-- | - Non-skipping succ: `b <= a || any (_ <= b) (succ a)`\n-- | - Non-skipping pred: `a <= b || any (b <= _) (pred a)`\n-- |\n-- | The retraction laws can intuitively be understood as saying that `succ` is\n-- | the opposite of `pred`; if you apply `succ` and then `pred` to something,\n-- | you should end up with what you started with (although of course this\n-- | doesn't apply if you tried to `succ` the last value in an enumeration and\n-- | therefore got `Nothing` out).\n-- |\n-- | The non-skipping laws can intuitively be understood as saying that `succ`\n-- | shouldn't skip over any elements of your type. For example, _without_ the\n-- | non-skipping laws, it would be permissible to write an `Enum Int` instance\n-- | where `succ x = Just (x+2)`, and similarly `pred x = Just (x-2)`.\nclass Ord a <= Enum a where\n  succ :: a -> Maybe a\n  pred :: a -> Maybe a\n\ninstance enumBoolean :: Enum Boolean where\n  succ false = Just true\n  succ _ = Nothing\n  pred true = Just false\n  pred _= Nothing\n\ninstance enumInt :: Enum Int where\n  succ n = if n < top then Just (n + 1) else Nothing\n  pred n = if n > bottom then Just (n - 1) else Nothing\n\ninstance enumChar :: Enum Char where\n  succ = defaultSucc charToEnum toCharCode\n  pred = defaultPred charToEnum toCharCode\n\ninstance enumUnit :: Enum Unit where\n  succ = const Nothing\n  pred = const Nothing\n\ninstance enumOrdering :: Enum Ordering where\n  succ LT = Just EQ\n  succ EQ = Just GT\n  succ GT = Nothing\n  pred LT = Nothing\n  pred EQ = Just LT\n  pred GT = Just EQ\n\ninstance enumMaybe :: BoundedEnum a => Enum (Maybe a) where\n  succ Nothing = Just (Just bottom)\n  succ (Just a) = Just <$> succ a\n  pred Nothing = Nothing\n  pred (Just a) = Just (pred a)\n\ninstance enumEither :: (BoundedEnum a, BoundedEnum b) => Enum (Either a b) where\n  succ (Left a) = maybe (Just (Right bottom)) (Just <<< Left) (succ a)\n  succ (Right b) = maybe Nothing (Just <<< Right) (succ b)\n  pred (Left a) = maybe Nothing (Just <<< Left) (pred a)\n  pred (Right b) = maybe (Just (Left top)) (Just <<< Right) (pred b)\n\ninstance enumTuple :: (Enum a, BoundedEnum b) => Enum (Tuple a b) where\n  succ (Tuple a b) = maybe (flip Tuple bottom <$> succ a) (Just <<< Tuple a) (succ b)\n  pred (Tuple a b) = maybe (flip Tuple top <$> pred a) (Just <<< Tuple a) (pred b)\n\n-- | Type class for finite enumerations.\n-- |\n-- | This should not be considered a part of a numeric hierarchy, as in Haskell.\n-- | Rather, this is a type class for small, ordered sum types with\n-- | statically-determined cardinality and the ability to easily compute\n-- | successor and predecessor elements like `DayOfWeek`.\n-- |\n-- | Laws:\n-- |\n-- | - ```succ bottom >>= succ >>= succ ... succ [cardinality - 1 times] == top```\n-- | - ```pred top    >>= pred >>= pred ... pred [cardinality - 1 times] == bottom```\n-- | - ```forall a > bottom: pred a >>= succ == Just a```\n-- | - ```forall a < top:  succ a >>= pred == Just a```\n-- | - ```forall a > bottom: fromEnum <$> pred a = pred (fromEnum a)```\n-- | - ```forall a < top:  fromEnum <$> succ a = succ (fromEnum a)```\n-- | - ```e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2```\n-- | - ```toEnum (fromEnum a) = Just a```\nclass (Bounded a, Enum a) <= BoundedEnum a where\n  cardinality :: Cardinality a\n  toEnum :: Int -> Maybe a\n  fromEnum :: a -> Int\n\ninstance boundedEnumBoolean :: BoundedEnum Boolean where\n  cardinality = Cardinality 2\n  toEnum 0 = Just false\n  toEnum 1 = Just true\n  toEnum _ = Nothing\n  fromEnum false = 0\n  fromEnum true = 1\n\ninstance boundedEnumChar :: BoundedEnum Char where\n  cardinality = Cardinality (toCharCode top - toCharCode bottom)\n  toEnum = charToEnum\n  fromEnum = toCharCode\n\ninstance boundedEnumUnit :: BoundedEnum Unit where\n  cardinality = Cardinality 1\n  toEnum 0 = Just unit\n  toEnum _ = Nothing\n  fromEnum = const 0\n\ninstance boundedEnumOrdering :: BoundedEnum Ordering where\n  cardinality = Cardinality 3\n  toEnum 0 = Just LT\n  toEnum 1 = Just EQ\n  toEnum 2 = Just GT\n  toEnum _ = Nothing\n  fromEnum LT = 0\n  fromEnum EQ = 1\n  fromEnum GT = 2\n\n-- | Like `toEnum` but returns the first argument if `x` is less than\n-- | `fromEnum bottom` and the second argument if `x` is greater than\n-- | `fromEnum top`.\n-- |\n-- | ``` purescript\n-- | toEnumWithDefaults False True (-1) -- False\n-- | toEnumWithDefaults False True 0    -- False\n-- | toEnumWithDefaults False True 1    -- True\n-- | toEnumWithDefaults False True 2    -- True\n-- | ```\ntoEnumWithDefaults :: forall a. BoundedEnum a => a -> a -> Int -> a\ntoEnumWithDefaults low high x = case toEnum x of\n  Just enum -> enum\n  Nothing -> if x < fromEnum (bottom :: a) then low else high\n\n-- | A type for the size of finite enumerations.\nnewtype Cardinality :: forall k. k -> Type\nnewtype Cardinality a = Cardinality Int\n\ntype role Cardinality representational\n\nderive instance newtypeCardinality :: Newtype (Cardinality a) _\nderive newtype instance eqCardinality :: Eq (Cardinality a)\nderive newtype instance ordCardinality :: Ord (Cardinality a)\n\ninstance showCardinality :: Show (Cardinality a) where\n  show (Cardinality n) = \"(Cardinality \" <> show n <> \")\"\n\n-- | Returns a contiguous sequence of elements from the first value to the\n-- | second value (inclusive).\n-- |\n-- | ``` purescript\n-- | enumFromTo 0 3 = [0, 1, 2, 3]\n-- | enumFromTo 'c' 'a' = ['c', 'b', 'a']\n-- | ```\n-- |\n-- | The example shows `Array` return values, but the result can be any type\n-- | with an `Unfoldable1` instance.\nenumFromTo :: forall a u. Enum a => Unfoldable1 u => a -> a -> u a\nenumFromTo = case _, _ of\n  from, to\n    | from == to -> singleton from\n    | from < to -> unfoldr1 (go succ (<=) to) from\n    | otherwise -> unfoldr1 (go pred (>=) to) from\n  where\n    go step op to a = Tuple a (step a >>= \\a' -> guard (a' `op` to) $> a')\n\n-- | Returns a sequence of elements from the first value, taking steps\n-- | according to the difference between the first and second value, up to\n-- | (but not exceeding) the third value.\n-- |\n-- | ``` purescript\n-- | enumFromThenTo 0 2 6 = [0, 2, 4, 6]\n-- | enumFromThenTo 0 3 5 = [0, 3]\n-- | ```\n-- |\n-- | Note that there is no `BoundedEnum` instance for integers, they're just\n-- | being used here for illustrative purposes to help clarify the behaviour.\n-- |\n-- | The example shows `Array` return values, but the result can be any type\n-- | with an `Unfoldable1` instance.\nenumFromThenTo :: forall f a. Unfoldable f => Functor f => BoundedEnum a => a -> a -> a -> f a\nenumFromThenTo = unsafePartial \\a b c ->\n  let\n    a' = fromEnum a\n    b' = fromEnum b\n    c' = fromEnum c\n  in\n    (toEnum >>> fromJust) <$> unfoldr (go (b' - a') c') a'\n  where\n    go step to e\n      | e <= to = Just (Tuple e (e + step))\n      | otherwise = Nothing\n\n-- | Produces all successors of an `Enum` value, excluding the start value.\nupFrom :: forall a u. Enum a => Unfoldable u => a -> u a\nupFrom = unfoldr (map diag <<< succ)\n\n-- | Produces all successors of an `Enum` value, including the start value.\n-- |\n-- | `upFromIncluding bottom` will return all values in an `Enum`.\nupFromIncluding :: \u2200 a u. Enum a => Unfoldable1 u => a -> u a\nupFromIncluding = unfoldr1 (Tuple <*> succ)\n\n-- | Produces all predecessors of an `Enum` value, excluding the start value.\ndownFrom :: forall a u. Enum a => Unfoldable u => a -> u a\ndownFrom = unfoldr (map diag <<< pred)\n\n-- | Produces all predecessors of an `Enum` value, including the start value.\n-- |\n-- | `downFromIncluding top` will return all values in an `Enum`, in reverse\n-- | order.\ndownFromIncluding :: forall a u. Enum a => Unfoldable1 u => a -> u a\ndownFromIncluding = unfoldr1 (Tuple <*> pred)\n\n-- | Provides a default implementation for `succ`, given a function that maps\n-- | integers to values in the `Enum`, and a function that maps values in the\n-- | `Enum` back to integers. The integer mapping must agree in both directions\n-- | for this to implement a law-abiding `succ`.\n-- |\n-- | If a `BoundedEnum` instance exists for `a`, the `toEnum` and `fromEnum`\n-- | functions can be used here:\n-- |\n-- | ``` purescript\n-- | succ = defaultSucc toEnum fromEnum\n-- | ```\ndefaultSucc :: forall a. (Int -> Maybe a) -> (a -> Int) -> a -> Maybe a\ndefaultSucc toEnum' fromEnum' a = toEnum' (fromEnum' a + 1)\n\n-- | Provides a default implementation for `pred`, given a function that maps\n-- | integers to values in the `Enum`, and a function that maps values in the\n-- | `Enum` back to integers. The integer mapping must agree in both directions\n-- | for this to implement a law-abiding `pred`.\n-- |\n-- | If a `BoundedEnum` instance exists for `a`, the `toEnum` and `fromEnum`\n-- | functions can be used here:\n-- |\n-- | ``` purescript\n-- | pred = defaultPred toEnum fromEnum\n-- | ```\ndefaultPred :: forall a. (Int -> Maybe a) -> (a -> Int) -> a -> Maybe a\ndefaultPred toEnum' fromEnum' a = toEnum' (fromEnum' a - 1)\n\n-- | Provides a default implementation for `cardinality`.\n-- |\n-- | Runs in `O(n)` where `n` is `fromEnum top`\ndefaultCardinality :: forall a. Bounded a => Enum a => Cardinality a\ndefaultCardinality = Cardinality $ go 1 (bottom :: a) where\n  go i x =\n    case succ x of\n      Just x' -> go (i + 1) x'\n      Nothing -> i\n\n-- | Provides a default implementation for `toEnum`.\n-- |\n-- | - Assumes `fromEnum bottom = 0`.\n-- | - Cannot be used in conjuction with `defaultSucc`.\n-- |\n-- | Runs in `O(n)` where `n` is `fromEnum a`.\ndefaultToEnum :: forall a. Bounded a => Enum a => Int -> Maybe a\ndefaultToEnum i' =\n  if i' < 0\n    then Nothing\n    else go i' bottom\n  where\n  go i x =\n    if i == 0\n      then Just x\n      -- We avoid using >>= here because it foils tail-call optimization\n      else case succ x of\n              Just x' -> go (i - 1) x'\n              Nothing -> Nothing\n\n-- | Provides a default implementation for `fromEnum`.\n-- |\n-- | - Assumes `toEnum 0 = Just bottom`.\n-- | - Cannot be used in conjuction with `defaultPred`.\n-- |\n-- | Runs in `O(n)` where `n` is `fromEnum a`.\ndefaultFromEnum :: forall a. Enum a => a -> Int\ndefaultFromEnum = go 0 where\n  go i x =\n    case pred x of\n      Just x' -> go (i + 1) x'\n      Nothing -> i\n\ndiag :: forall a. a -> Tuple a a\ndiag a = Tuple a a\n\ncharToEnum :: Int -> Maybe Char\ncharToEnum n | n >= toCharCode bottom && n <= toCharCode top = Just (fromCharCode n)\ncharToEnum _ = Nothing\n\nforeign import toCharCode :: Char -> Int\nforeign import fromCharCode :: Int -> Char\n", "// module Data.Function.Uncurried\n\nexport const mkFn0 = function (fn) {\n  return function () {\n    return fn();\n  };\n};\n\nexport const mkFn2 = function (fn) {\n  /* jshint maxparams: 2 */\n  return function (a, b) {\n    return fn(a)(b);\n  };\n};\n\nexport const mkFn3 = function (fn) {\n  /* jshint maxparams: 3 */\n  return function (a, b, c) {\n    return fn(a)(b)(c);\n  };\n};\n\nexport const mkFn4 = function (fn) {\n  /* jshint maxparams: 4 */\n  return function (a, b, c, d) {\n    return fn(a)(b)(c)(d);\n  };\n};\n\nexport const mkFn5 = function (fn) {\n  /* jshint maxparams: 5 */\n  return function (a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e);\n  };\n};\n\nexport const mkFn6 = function (fn) {\n  /* jshint maxparams: 6 */\n  return function (a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f);\n  };\n};\n\nexport const mkFn7 = function (fn) {\n  /* jshint maxparams: 7 */\n  return function (a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g);\n  };\n};\n\nexport const mkFn8 = function (fn) {\n  /* jshint maxparams: 8 */\n  return function (a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h);\n  };\n};\n\nexport const mkFn9 = function (fn) {\n  /* jshint maxparams: 9 */\n  return function (a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i);\n  };\n};\n\nexport const mkFn10 = function (fn) {\n  /* jshint maxparams: 10 */\n  return function (a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j);\n  };\n};\n\nexport const runFn0 = function (fn) {\n  return fn();\n};\n\nexport const runFn2 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return fn(a, b);\n    };\n  };\n};\n\nexport const runFn3 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return fn(a, b, c);\n      };\n    };\n  };\n};\n\nexport const runFn4 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return fn(a, b, c, d);\n        };\n      };\n    };\n  };\n};\n\nexport const runFn5 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return fn(a, b, c, d, e);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn6 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return fn(a, b, c, d, e, f);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn7 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return fn(a, b, c, d, e, f, g);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn8 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return fn(a, b, c, d, e, f, g, h);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn9 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return fn(a, b, c, d, e, f, g, h, i);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn10 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return function (j) {\n                      return fn(a, b, c, d, e, f, g, h, i, j);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n", "/* global Symbol */\n\nvar hasArrayFrom = typeof Array.from === \"function\";\nvar hasStringIterator =\n  typeof Symbol !== \"undefined\" &&\n  Symbol != null &&\n  typeof Symbol.iterator !== \"undefined\" &&\n  typeof String.prototype[Symbol.iterator] === \"function\";\nvar hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\nvar hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n\nexport const _unsafeCodePointAt0 = function (fallback) {\n  return hasCodePointAt\n    ? function (str) { return str.codePointAt(0); }\n    : fallback;\n};\n\nexport const _codePointAt = function (fallback) {\n  return function (Just) {\n    return function (Nothing) {\n      return function (unsafeCodePointAt0) {\n        return function (index) {\n          return function (str) {\n            var length = str.length;\n            if (index < 0 || index >= length) return Nothing;\n            if (hasStringIterator) {\n              var iter = str[Symbol.iterator]();\n              for (var i = index;; --i) {\n                var o = iter.next();\n                if (o.done) return Nothing;\n                if (i === 0) return Just(unsafeCodePointAt0(o.value));\n              }\n            }\n            return fallback(index)(str);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const _countPrefix = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasStringIterator) {\n      return function (pred) {\n        return function (str) {\n          var iter = str[Symbol.iterator]();\n          for (var cpCount = 0; ; ++cpCount) {\n            var o = iter.next();\n            if (o.done) return cpCount;\n            var cp = unsafeCodePointAt0(o.value);\n            if (!pred(cp)) return cpCount;\n          }\n        };\n      };\n    }\n    return fallback;\n  };\n};\n\nexport const _fromCodePointArray = function (singleton) {\n  return hasFromCodePoint\n    ? function (cps) {\n      // Function.prototype.apply will fail for very large second parameters,\n      // so we don't use it for arrays with 10,000 or more entries.\n      if (cps.length < 10e3) {\n        return String.fromCodePoint.apply(String, cps);\n      }\n      return cps.map(singleton).join(\"\");\n    }\n    : function (cps) {\n      return cps.map(singleton).join(\"\");\n    };\n};\n\nexport const _singleton = function (fallback) {\n  return hasFromCodePoint ? String.fromCodePoint : fallback;\n};\n\nexport const _take = function (fallback) {\n  return function (n) {\n    if (hasStringIterator) {\n      return function (str) {\n        var accum = \"\";\n        var iter = str[Symbol.iterator]();\n        for (var i = 0; i < n; ++i) {\n          var o = iter.next();\n          if (o.done) return accum;\n          accum += o.value;\n        }\n        return accum;\n      };\n    }\n    return fallback(n);\n  };\n};\n\nexport const _toCodePointArray = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasArrayFrom) {\n      return function (str) {\n        return Array.from(str, unsafeCodePointAt0);\n      };\n    }\n    return fallback;\n  };\n};\n", "export const fromCharArray = function (a) {\n  return a.join(\"\");\n};\n\nexport const toCharArray = function (s) {\n  return s.split(\"\");\n};\n\nexport const singleton = function (c) {\n  return c;\n};\n\nexport const _charAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (s) {\n        return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;\n      };\n    };\n  };\n};\n\nexport const _toChar = function (just) {\n  return function (nothing) {\n    return function (s) {\n      return s.length === 1 ? just(s) : nothing;\n    };\n  };\n};\n\nexport const length = function (s) {\n  return s.length;\n};\n\nexport const countPrefix = function (p) {\n  return function (s) {\n    var i = 0;\n    while (i < s.length && p(s.charAt(i))) i++;\n    return i;\n  };\n};\n\nexport const _indexOf = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (s) {\n        var i = s.indexOf(x);\n        return i === -1 ? nothing : just(i);\n      };\n    };\n  };\n};\n\nexport const _indexOfStartingAt = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (startAt) {\n        return function (s) {\n          if (startAt < 0 || startAt > s.length) return nothing;\n          var i = s.indexOf(x, startAt);\n          return i === -1 ? nothing : just(i);\n        };\n      };\n    };\n  };\n};\n\nexport const _lastIndexOf = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (s) {\n        var i = s.lastIndexOf(x);\n        return i === -1 ? nothing : just(i);\n      };\n    };\n  };\n};\n\nexport const _lastIndexOfStartingAt = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (startAt) {\n        return function (s) {\n          var i = s.lastIndexOf(x, startAt);\n          return i === -1 ? nothing : just(i);\n        };\n      };\n    };\n  };\n};\n\nexport const take = function (n) {\n  return function (s) {\n    return s.substr(0, n);\n  };\n};\n\nexport const drop = function (n) {\n  return function (s) {\n    return s.substring(n);\n  };\n};\n\nexport const slice = function (b) {\n  return function (e) {\n    return function (s) {\n      return s.slice(b,e);\n    };\n  };\n};\n\nexport const splitAt = function (i) {\n  return function (s) {\n    return { before: s.substring(0, i), after: s.substring(i) };\n  };\n};\n", "export const charAt = function (i) {\n  return function (s) {\n    if (i >= 0 && i < s.length) return s.charAt(i);\n    throw new Error(\"Data.String.Unsafe.charAt: Invalid index.\");\n  };\n};\n\nexport const char = function (s) {\n  if (s.length === 1) return s.charAt(0);\n  throw new Error(\"Data.String.Unsafe.char: Expected string of length 1.\");\n};\n", "module Data.String.CodeUnits\n  ( stripPrefix\n  , stripSuffix\n  , contains\n  , singleton\n  , fromCharArray\n  , toCharArray\n  , charAt\n  , toChar\n  , uncons\n  , length\n  , countPrefix\n  , indexOf\n  , indexOf'\n  , lastIndexOf\n  , lastIndexOf'\n  , take\n  , takeRight\n  , takeWhile\n  , drop\n  , dropRight\n  , dropWhile\n  , slice\n  , splitAt\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..), isJust)\nimport Data.String.Pattern (Pattern(..))\nimport Data.String.Unsafe as U\n\n-------------------------------------------------------------------------------\n-- `stripPrefix`, `stripSuffix`, and `contains` are CodeUnit/CodePoint agnostic\n-- as they are based on patterns rather than lengths/indices, but they need to\n-- be defined in here to avoid a circular module dependency\n-------------------------------------------------------------------------------\n\n-- | If the string starts with the given prefix, return the portion of the\n-- | string left after removing it, as a `Just` value. Otherwise, return `Nothing`.\n-- |\n-- | ```purescript\n-- | stripPrefix (Pattern \"http:\") \"http://purescript.org\" == Just \"//purescript.org\"\n-- | stripPrefix (Pattern \"http:\") \"https://purescript.org\" == Nothing\n-- | ```\nstripPrefix :: Pattern -> String -> Maybe String\nstripPrefix (Pattern prefix) str =\n  let { before, after } = splitAt (length prefix) str in\n  if before == prefix then Just after else Nothing\n\n-- | If the string ends with the given suffix, return the portion of the\n-- | string left after removing it, as a `Just` value. Otherwise, return\n-- | `Nothing`.\n-- |\n-- | ```purescript\n-- | stripSuffix (Pattern \".exe\") \"psc.exe\" == Just \"psc\"\n-- | stripSuffix (Pattern \".exe\") \"psc\" == Nothing\n-- | ```\nstripSuffix :: Pattern -> String -> Maybe String\nstripSuffix (Pattern suffix) str =\n  let { before, after } = splitAt (length str - length suffix) str in\n  if after == suffix then Just before else Nothing\n\n-- | Checks whether the pattern appears in the given string.\n-- |\n-- | ```purescript\n-- | contains (Pattern \"needle\") \"haystack with needle\" == true\n-- | contains (Pattern \"needle\") \"haystack\" == false\n-- | ```\ncontains :: Pattern -> String -> Boolean\ncontains pat = isJust <<< indexOf pat\n\n-------------------------------------------------------------------------------\n-- all functions past this point are CodeUnit specific\n-------------------------------------------------------------------------------\n\n-- | Returns a string of length `1` containing the given character.\n-- |\n-- | ```purescript\n-- | singleton 'l' == \"l\"\n-- | ```\n-- |\nforeign import singleton :: Char -> String\n\n-- | Converts an array of characters into a string.\n-- |\n-- | ```purescript\n-- | fromCharArray ['H', 'e', 'l', 'l', 'o'] == \"Hello\"\n-- | ```\nforeign import fromCharArray :: Array Char -> String\n\n-- | Converts the string into an array of characters.\n-- |\n-- | ```purescript\n-- | toCharArray \"Hello\u263A\\n\" == ['H','e','l','l','o','\u263A','\\n']\n-- | ```\nforeign import toCharArray :: String -> Array Char\n\n-- | Returns the character at the given index, if the index is within bounds.\n-- |\n-- | ```purescript\n-- | charAt 2 \"Hello\" == Just 'l'\n-- | charAt 10 \"Hello\" == Nothing\n-- | ```\n-- |\ncharAt :: Int -> String -> Maybe Char\ncharAt = _charAt Just Nothing\n\nforeign import _charAt\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Int\n  -> String\n  -> Maybe Char\n\n-- | Converts the string to a character, if the length of the string is\n-- | exactly `1`.\n-- |\n-- | ```purescript\n-- | toChar \"l\" == Just 'l'\n-- | toChar \"Hi\" == Nothing -- since length is not 1\n-- | ```\ntoChar :: String -> Maybe Char\ntoChar = _toChar Just Nothing\n\nforeign import _toChar\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> String\n  -> Maybe Char\n\n-- | Returns the first character and the rest of the string,\n-- | if the string is not empty.\n-- |\n-- | ```purescript\n-- | uncons \"\" == Nothing\n-- | uncons \"Hello World\" == Just { head: 'H', tail: \"ello World\" }\n-- | ```\n-- |\nuncons :: String -> Maybe { head :: Char, tail :: String }\nuncons \"\" = Nothing\nuncons s  = Just { head: U.charAt zero s, tail: drop one s }\n\n-- | Returns the number of characters the string is composed of.\n-- |\n-- | ```purescript\n-- | length \"Hello World\" == 11\n-- | ```\n-- |\nforeign import length :: String -> Int\n\n-- | Returns the number of contiguous characters at the beginning\n-- | of the string for which the predicate holds.\n-- |\n-- | ```purescript\n-- | countPrefix (_ /= ' ') \"Hello World\" == 5 -- since length \"Hello\" == 5\n-- | ```\n-- |\nforeign import countPrefix :: (Char -> Boolean) -> String -> Int\n\n-- | Returns the index of the first occurrence of the pattern in the\n-- | given string. Returns `Nothing` if there is no match.\n-- |\n-- | ```purescript\n-- | indexOf (Pattern \"c\") \"abcdc\" == Just 2\n-- | indexOf (Pattern \"c\") \"aaa\" == Nothing\n-- | ```\n-- |\nindexOf :: Pattern -> String -> Maybe Int\nindexOf = _indexOf Just Nothing\n\nforeign import _indexOf\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> String\n  -> Maybe Int\n\n-- | Returns the index of the first occurrence of the pattern in the\n-- | given string, starting at the specified index. Returns `Nothing` if there is\n-- | no match.\n-- |\n-- | ```purescript\n-- | indexOf' (Pattern \"a\") 2 \"ababa\" == Just 2\n-- | indexOf' (Pattern \"a\") 3 \"ababa\" == Just 4\n-- | ```\n-- |\nindexOf' :: Pattern -> Int -> String -> Maybe Int\nindexOf' = _indexOfStartingAt Just Nothing\n\nforeign import _indexOfStartingAt\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> Int\n  -> String\n  -> Maybe Int\n\n-- | Returns the index of the last occurrence of the pattern in the\n-- | given string. Returns `Nothing` if there is no match.\n-- |\n-- | ```purescript\n-- | lastIndexOf (Pattern \"c\") \"abcdc\" == Just 4\n-- | lastIndexOf (Pattern \"c\") \"aaa\" == Nothing\n-- | ```\n-- |\nlastIndexOf :: Pattern -> String -> Maybe Int\nlastIndexOf = _lastIndexOf Just Nothing\n\nforeign import _lastIndexOf\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> String\n  -> Maybe Int\n\n-- | Returns the index of the last occurrence of the pattern in the\n-- | given string, starting at the specified index and searching\n-- | backwards towards the beginning of the string.\n-- |\n-- | Starting at a negative index is equivalent to starting at 0 and\n-- | starting at an index greater than the string length is equivalent\n-- | to searching in the whole string.\n-- |\n-- | Returns `Nothing` if there is no match.\n-- |\n-- | ```purescript\n-- | lastIndexOf' (Pattern \"a\") (-1) \"ababa\" == Just 0\n-- | lastIndexOf' (Pattern \"a\") 1 \"ababa\" == Just 0\n-- | lastIndexOf' (Pattern \"a\") 3 \"ababa\" == Just 2\n-- | lastIndexOf' (Pattern \"a\") 4 \"ababa\" == Just 4\n-- | lastIndexOf' (Pattern \"a\") 5 \"ababa\" == Just 4\n-- | ```\n-- |\nlastIndexOf' :: Pattern -> Int -> String -> Maybe Int\nlastIndexOf' = _lastIndexOfStartingAt Just Nothing\n\nforeign import _lastIndexOfStartingAt\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> Int\n  -> String\n  -> Maybe Int\n\n-- | Returns the first `n` characters of the string.\n-- |\n-- | ```purescript\n-- | take 5 \"Hello World\" == \"Hello\"\n-- | ```\n-- |\nforeign import take :: Int -> String -> String\n\n-- | Returns the last `n` characters of the string.\n-- |\n-- | ```purescript\n-- | takeRight 5 \"Hello World\" == \"World\"\n-- | ```\n-- |\ntakeRight :: Int -> String -> String\ntakeRight i s = drop (length s - i) s\n\n-- | Returns the longest prefix (possibly empty) of characters that satisfy\n-- | the predicate.\n-- |\n-- | ```purescript\n-- | takeWhile (_ /= ':') \"http://purescript.org\" == \"http\"\n-- | ```\n-- |\ntakeWhile :: (Char -> Boolean) -> String -> String\ntakeWhile p s = take (countPrefix p s) s\n\n-- | Returns the string without the first `n` characters.\n-- |\n-- | ```purescript\n-- | drop 6 \"Hello World\" == \"World\"\n-- | ```\n-- |\nforeign import drop :: Int -> String -> String\n\n-- | Returns the string without the last `n` characters.\n-- |\n-- | ```purescript\n-- | dropRight 6 \"Hello World\" == \"Hello\"\n-- | ```\n-- |\ndropRight :: Int -> String -> String\ndropRight i s = take (length s - i) s\n\n-- | Returns the suffix remaining after `takeWhile`.\n-- |\n-- | ```purescript\n-- | dropWhile (_ /= '.') \"Test.purs\" == \".purs\"\n-- | ```\n-- |\ndropWhile :: (Char -> Boolean) -> String -> String\ndropWhile p s = drop (countPrefix p s) s\n\n-- | Returns the substring at indices `[begin, end)`.\n-- | If either index is negative, it is normalised to `length s - index`,\n-- | where `s` is the input string. `\"\"` is returned if either\n-- | index is out of bounds or if `begin > end` after normalisation.\n-- |\n-- | ```purescript\n-- | slice 0 0   \"purescript\" == \"\"\n-- | slice 0 1   \"purescript\" == \"p\"\n-- | slice 3 6   \"purescript\" == \"esc\"\n-- | slice (-4) (-1) \"purescript\" == \"rip\"\n-- | slice (-4) 3  \"purescript\" == \"\"\n-- | ```\nforeign import slice :: Int -> Int -> String -> String\n\n-- | Splits a string into two substrings, where `before` contains the\n-- | characters up to (but not including) the given index, and `after` contains\n-- | the rest of the string, from that index on.\n-- |\n-- | ```purescript\n-- | splitAt 2 \"Hello World\" == { before: \"He\", after: \"llo World\"}\n-- | splitAt 10 \"Hi\" == { before: \"Hi\", after: \"\"}\n-- | ```\n-- |\n-- | Thus the length of `(splitAt i s).before` will equal either `i` or\n-- | `length s`, if that is shorter. (Or if `i` is negative the length will be\n-- | 0.)\n-- |\n-- | In code:\n-- | ```purescript\n-- | length (splitAt i s).before == min (max i 0) (length s)\n-- | (splitAt i s).before <> (splitAt i s).after == s\n-- | splitAt i s == {before: take i s, after: drop i s}\n-- | ```\nforeign import splitAt :: Int -> String -> { before :: String, after :: String }\n", "-- | These functions allow PureScript strings to be treated as if they were\n-- | sequences of Unicode code points instead of their true underlying\n-- | implementation (sequences of UTF-16 code units). For nearly all uses of\n-- | strings, these functions should be preferred over the ones in\n-- | `Data.String.CodeUnits`.\nmodule Data.String.CodePoints\n  ( module Exports\n  , CodePoint\n  , codePointFromChar\n  , singleton\n  , fromCodePointArray\n  , toCodePointArray\n  , codePointAt\n  , uncons\n  , length\n  , countPrefix\n  , indexOf\n  , indexOf'\n  , lastIndexOf\n  , lastIndexOf'\n  , take\n  -- , takeRight\n  , takeWhile\n  , drop\n  -- , dropRight\n  , dropWhile\n  -- , slice\n  , splitAt\n  ) where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Enum (class BoundedEnum, class Enum, Cardinality(..), defaultPred, defaultSucc, fromEnum, toEnum, toEnumWithDefaults)\nimport Data.Int (hexadecimal, toStringAs)\nimport Data.Maybe (Maybe(..))\nimport Data.String.CodeUnits (contains, stripPrefix, stripSuffix) as Exports\nimport Data.String.CodeUnits as CU\nimport Data.String.Common (toUpper)\nimport Data.String.Pattern (Pattern)\nimport Data.String.Unsafe as Unsafe\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (unfoldr)\n\n-- | CodePoint is an `Int` bounded between `0` and `0x10FFFF`, corresponding to\n-- | Unicode code points.\nnewtype CodePoint = CodePoint Int\n\nderive instance eqCodePoint :: Eq CodePoint\nderive instance ordCodePoint :: Ord CodePoint\n\ninstance showCodePoint :: Show CodePoint where\n  show (CodePoint i) = \"(CodePoint 0x\" <> toUpper (toStringAs hexadecimal i) <> \")\"\n\ninstance boundedCodePoint :: Bounded CodePoint where\n  bottom = CodePoint 0\n  top = CodePoint 0x10FFFF\n\ninstance enumCodePoint :: Enum CodePoint where\n  succ = defaultSucc toEnum fromEnum\n  pred = defaultPred toEnum fromEnum\n\ninstance boundedEnumCodePoint :: BoundedEnum CodePoint where\n  cardinality = Cardinality (0x10FFFF + 1)\n  fromEnum (CodePoint n) = n\n  toEnum n\n    | n >= 0 && n <= 0x10FFFF = Just (CodePoint n)\n    | otherwise = Nothing\n\n-- | Creates a `CodePoint` from a given `Char`.\n-- |\n-- | ```purescript\n-- | >>> codePointFromChar 'B'\n-- | CodePoint 0x42 -- represents 'B'\n-- | ```\n-- |\ncodePointFromChar :: Char -> CodePoint\ncodePointFromChar = fromEnum >>> CodePoint\n\n-- | Creates a string containing just the given code point. Operates in\n-- | constant space and time.\n-- |\n-- | ```purescript\n-- | >>> map singleton (toEnum 0x1D400)\n-- | Just \"\uD835\uDC00\"\n-- | ```\n-- |\nsingleton :: CodePoint -> String\nsingleton = _singleton singletonFallback\n\nforeign import _singleton\n  :: (CodePoint -> String)\n  -> CodePoint\n  -> String\n\nsingletonFallback :: CodePoint -> String\nsingletonFallback (CodePoint cp) | cp <= 0xFFFF = fromCharCode cp\nsingletonFallback (CodePoint cp) =\n  let lead = ((cp - 0x10000) / 0x400) + 0xD800 in\n  let trail = (cp - 0x10000) `mod` 0x400 + 0xDC00 in\n  fromCharCode lead <> fromCharCode trail\n\n-- | Creates a string from an array of code points. Operates in space and time\n-- | linear to the length of the array.\n-- |\n-- | ```purescript\n-- | >>> codePointArray = toCodePointArray \"c \uD835\uDC00\"\n-- | >>> codePointArray\n-- | [CodePoint 0x63, CodePoint 0x20, CodePoint 0x1D400]\n-- | >>> fromCodePointArray codePointArray\n-- | \"c \uD835\uDC00\"\n-- | ```\n-- |\nfromCodePointArray :: Array CodePoint -> String\nfromCodePointArray = _fromCodePointArray singletonFallback\n\nforeign import _fromCodePointArray\n  :: (CodePoint -> String)\n  -> Array CodePoint\n  -> String\n\n-- | Creates an array of code points from a string. Operates in space and time\n-- | linear to the length of the string.\n-- |\n-- | ```purescript\n-- | >>> codePointArray = toCodePointArray \"b \uD835\uDC00\uD835\uDC00\"\n-- | >>> codePointArray\n-- | [CodePoint 0x62, CodePoint 0x20, CodePoint 0x1D400, CodePoint 0x1D400]\n-- | >>> map singleton codePointArray\n-- | [\"b\", \" \", \"\uD835\uDC00\", \"\uD835\uDC00\"]\n-- | ```\n-- |\ntoCodePointArray :: String -> Array CodePoint\ntoCodePointArray = _toCodePointArray toCodePointArrayFallback unsafeCodePointAt0\n\nforeign import _toCodePointArray\n  :: (String -> Array CodePoint)\n  -> (String -> CodePoint)\n  -> String\n  -> Array CodePoint\n\ntoCodePointArrayFallback :: String -> Array CodePoint\ntoCodePointArrayFallback s = unfoldr unconsButWithTuple s\n\nunconsButWithTuple :: String -> Maybe (Tuple CodePoint String)\nunconsButWithTuple s = (\\{ head, tail } -> Tuple head tail) <$> uncons s\n\n-- | Returns the first code point of the string after dropping the given number\n-- | of code points from the beginning, if there is such a code point. Operates\n-- | in constant space and in time linear to the given index.\n-- |\n-- | ```purescript\n-- | >>> codePointAt 1 \"\uD835\uDC00\uD835\uDC00\uD835\uDC00\uD835\uDC00\"\n-- | Just (CodePoint 0x1D400) -- represents \"\uD835\uDC00\"\n-- | -- compare to Data.String:\n-- | >>> charAt 1 \"\uD835\uDC00\uD835\uDC00\uD835\uDC00\uD835\uDC00\"\n-- | Just '\uFFFD'\n-- | ```\n-- |\ncodePointAt :: Int -> String -> Maybe CodePoint\ncodePointAt n _ | n < 0 = Nothing\ncodePointAt 0 \"\" = Nothing\ncodePointAt 0 s = Just (unsafeCodePointAt0 s)\ncodePointAt n s = _codePointAt codePointAtFallback Just Nothing unsafeCodePointAt0 n s\n\nforeign import _codePointAt\n  :: (Int -> String -> Maybe CodePoint)\n  -> (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> (String -> CodePoint)\n  -> Int\n  -> String\n  -> Maybe CodePoint\n\ncodePointAtFallback :: Int -> String -> Maybe CodePoint\ncodePointAtFallback n s = case uncons s of\n  Just { head, tail } -> if n == 0 then Just head else codePointAtFallback (n - 1) tail\n  _ -> Nothing\n\n-- | Returns a record with the first code point and the remaining code points\n-- | of the string. Returns `Nothing` if the string is empty. Operates in\n-- | constant space and time.\n-- |\n-- | ```purescript\n-- | >>> uncons \"\uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just { head: CodePoint 0x1D400, tail: \"\uD835\uDC00 c \uD835\uDC00\" }\n-- | >>> uncons \"\"\n-- | Nothing\n-- | ```\n-- |\nuncons :: String -> Maybe { head :: CodePoint, tail :: String }\nuncons s = case CU.length s of\n  0 -> Nothing\n  1 -> Just { head: CodePoint (fromEnum (Unsafe.charAt 0 s)), tail: \"\" }\n  _ ->\n    let\n      cu0 = fromEnum (Unsafe.charAt 0 s)\n      cu1 = fromEnum (Unsafe.charAt 1 s)\n    in\n      if isLead cu0 && isTrail cu1\n        then Just { head: unsurrogate cu0 cu1, tail: CU.drop 2 s }\n        else Just { head: CodePoint cu0, tail: CU.drop 1 s }\n\n-- | Returns the number of code points in the string. Operates in constant\n-- | space and in time linear to the length of the string.\n-- |\n-- | ```purescript\n-- | >>> length \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | 8\n-- | -- compare to Data.String:\n-- | >>> length \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | 11\n-- | ```\n-- |\nlength :: String -> Int\nlength = Array.length <<< toCodePointArray\n\n-- | Returns the number of code points in the leading sequence of code points\n-- | which all match the given predicate. Operates in constant space and in\n-- | time linear to the length of the string.\n-- |\n-- | ```purescript\n-- | >>> countPrefix (\\c -> fromEnum c == 0x1D400) \"\uD835\uDC00\uD835\uDC00 b c \uD835\uDC00\"\n-- | 2\n-- | ```\n-- |\ncountPrefix :: (CodePoint -> Boolean) -> String -> Int\ncountPrefix = _countPrefix countFallback unsafeCodePointAt0\n\nforeign import _countPrefix\n  :: ((CodePoint -> Boolean) -> String -> Int)\n  -> (String -> CodePoint)\n  -> (CodePoint -> Boolean)\n  -> String\n  -> Int\n\ncountFallback :: (CodePoint -> Boolean) -> String -> Int\ncountFallback p s = countTail p s 0\n\ncountTail :: (CodePoint -> Boolean) -> String -> Int -> Int\ncountTail p s accum = case uncons s of\n  Just { head, tail } -> if p head then countTail p tail (accum + 1) else accum\n  _ -> accum\n\n-- | Returns the number of code points preceding the first match of the given\n-- | pattern in the string. Returns `Nothing` when no matches are found.\n-- |\n-- | ```purescript\n-- | >>> indexOf (Pattern \"\uD835\uDC00\") \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just 2\n-- | >>> indexOf (Pattern \"o\") \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | ```\n-- |\nindexOf :: Pattern -> String -> Maybe Int\nindexOf p s = (\\i -> length (CU.take i s)) <$> CU.indexOf p s\n\n-- | Returns the number of code points preceding the first match of the given\n-- | pattern in the string. Pattern matches preceding the given index will be\n-- | ignored. Returns `Nothing` when no matches are found.\n-- |\n-- | ```purescript\n-- | >>> indexOf' (Pattern \"\uD835\uDC00\") 4 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just 7\n-- | >>> indexOf' (Pattern \"o\") 4 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | ```\n-- |\nindexOf' :: Pattern -> Int -> String -> Maybe Int\nindexOf' p i s =\n  let s' = drop i s in\n  (\\k -> i + length (CU.take k s')) <$> CU.indexOf p s'\n\n-- | Returns the number of code points preceding the last match of the given\n-- | pattern in the string. Returns `Nothing` when no matches are found.\n-- |\n-- | ```purescript\n-- | >>> lastIndexOf (Pattern \"\uD835\uDC00\") \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just 7\n-- | >>> lastIndexOf (Pattern \"o\") \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | ```\n-- |\nlastIndexOf :: Pattern -> String -> Maybe Int\nlastIndexOf p s = (\\i -> length (CU.take i s)) <$> CU.lastIndexOf p s\n\n-- | Returns the number of code points preceding the first match of the given\n-- | pattern in the string. Pattern matches following the given index will be\n-- | ignored.\n-- |\n-- | Giving a negative index is equivalent to giving 0 and giving an index\n-- | greater than the number of code points in the string is equivalent to\n-- | searching in the whole string.\n-- |\n-- | Returns `Nothing` when no matches are found.\n-- |\n-- | ```purescript\n-- | >>> lastIndexOf' (Pattern \"\uD835\uDC00\") (-1) \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | >>> lastIndexOf' (Pattern \"\uD835\uDC00\") 0 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | >>> lastIndexOf' (Pattern \"\uD835\uDC00\") 5 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just 3\n-- | >>> lastIndexOf' (Pattern \"\uD835\uDC00\") 8 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just 7\n-- | >>> lastIndexOf' (Pattern \"o\") 5 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | ```\n-- |\nlastIndexOf' :: Pattern -> Int -> String -> Maybe Int\nlastIndexOf' p i s =\n  let i' = CU.length (take i s) in\n  (\\k -> length (CU.take k s)) <$> CU.lastIndexOf' p i' s\n\n-- | Returns a string containing the given number of code points from the\n-- | beginning of the given string. If the string does not have that many code\n-- | points, returns the empty string. Operates in constant space and in time\n-- | linear to the given number.\n-- |\n-- | ```purescript\n-- | >>> take 3 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | \"b \uD835\uDC00\"\n-- | -- compare to Data.String:\n-- | >>> take 3 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | \"b \uFFFD\"\n-- | ```\n-- |\ntake :: Int -> String -> String\ntake = _take takeFallback\n\nforeign import _take :: (Int -> String -> String) -> Int -> String -> String\n\ntakeFallback :: Int -> String -> String\ntakeFallback n _ | n < 1 = \"\"\ntakeFallback n s = case uncons s of\n  Just { head, tail } -> singleton head <> takeFallback (n - 1) tail\n  _ -> s\n\n-- | Returns a string containing the leading sequence of code points which all\n-- | match the given predicate from the string. Operates in constant space and\n-- | in time linear to the length of the string.\n-- |\n-- | ```purescript\n-- | >>> takeWhile (\\c -> fromEnum c == 0x1D400) \"\uD835\uDC00\uD835\uDC00 b c \uD835\uDC00\"\n-- | \"\uD835\uDC00\uD835\uDC00\"\n-- | ```\n-- |\ntakeWhile :: (CodePoint -> Boolean) -> String -> String\ntakeWhile p s = take (countPrefix p s) s\n\n-- | Drops the given number of code points from the beginning of the string. If\n-- | the string does not have that many code points, returns the empty string.\n-- | Operates in constant space and in time linear to the given number.\n-- |\n-- | ```purescript\n-- | >>> drop 5 \"\uD835\uDC00\uD835\uDC00 b c\"\n-- | \"c\"\n-- | -- compared to Data.String:\n-- | >>> drop 5 \"\uD835\uDC00\uD835\uDC00 b c\"\n-- | \"b c\" -- because \"\uD835\uDC00\" occupies 2 code units\n-- | ```\n-- |\ndrop :: Int -> String -> String\ndrop n s = CU.drop (CU.length (take n s)) s\n\n-- | Drops the leading sequence of code points which all match the given\n-- | predicate from the string. Operates in constant space and in time linear\n-- | to the length of the string.\n-- |\n-- | ```purescript\n-- | >>> dropWhile (\\c -> fromEnum c == 0x1D400) \"\uD835\uDC00\uD835\uDC00 b c \uD835\uDC00\"\n-- | \" b c \uD835\uDC00\"\n-- | ```\n-- |\ndropWhile :: (CodePoint -> Boolean) -> String -> String\ndropWhile p s = drop (countPrefix p s) s\n\n-- | Splits a string into two substrings, where `before` contains the code\n-- | points up to (but not including) the given index, and `after` contains the\n-- | rest of the string, from that index on.\n-- |\n-- | ```purescript\n-- | >>> splitAt 3 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | { before: \"b \uD835\uDC00\", after: \"\uD835\uDC00 c \uD835\uDC00\" }\n-- | ```\n-- |\n-- | Thus the length of `(splitAt i s).before` will equal either `i` or\n-- | `length s`, if that is shorter. (Or if `i` is negative the length will be\n-- | 0.)\n-- |\n-- | In code:\n-- | ```purescript\n-- | length (splitAt i s).before == min (max i 0) (length s)\n-- | (splitAt i s).before <> (splitAt i s).after == s\n-- | splitAt i s == {before: take i s, after: drop i s}\n-- | ```\nsplitAt :: Int -> String -> { before :: String, after :: String }\nsplitAt i s =\n  let before = take i s in\n  { before\n  -- inline drop i s to reuse the result of take i s\n  , after: CU.drop (CU.length before) s\n  }\n\nunsurrogate :: Int -> Int -> CodePoint\nunsurrogate lead trail = CodePoint ((lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000)\n\nisLead :: Int -> Boolean\nisLead cu = 0xD800 <= cu && cu <= 0xDBFF\n\nisTrail :: Int -> Boolean\nisTrail cu = 0xDC00 <= cu && cu <= 0xDFFF\n\nfromCharCode :: Int -> String\nfromCharCode = CU.singleton <<< toEnumWithDefaults bottom top\n\n-- WARN: this function expects the String parameter to be non-empty\nunsafeCodePointAt0 :: String -> CodePoint\nunsafeCodePointAt0 = _unsafeCodePointAt0 unsafeCodePointAt0Fallback\n\nforeign import _unsafeCodePointAt0\n  :: (String -> CodePoint)\n  -> String\n  -> CodePoint\n\nunsafeCodePointAt0Fallback :: String -> CodePoint\nunsafeCodePointAt0Fallback s =\n  let\n    cu0 = fromEnum (Unsafe.charAt 0 s)\n  in\n    if isLead cu0 && CU.length s > 1\n       then\n         let cu1 = fromEnum (Unsafe.charAt 1 s) in\n         if isTrail cu1 then unsurrogate cu0 cu1 else CodePoint cu0\n       else\n         CodePoint cu0\n", "-- | Primitive parsers, combinators and functions for working with an input\n-- | stream of type `String`.\n-- |\n-- | All of these primitive parsers will consume when they succeed.\n-- |\n-- | All of these primitive parsers will not consume and will automatically\n-- | backtrack when they fail.\n-- |\n-- | The behavior of these primitive parsers is based on the behavior of the\n-- | `Data.String` module in the __strings__ package.\n-- | In most JavaScript runtime environments, the `String`\n-- | is little-endian [UTF-16](https://en.wikipedia.org/wiki/UTF-16).\n-- |\n-- | The primitive parsers which return `Char` will only succeed when the character\n-- | being parsed is a code point in the\n-- | [Basic Multilingual Plane](https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane)\n-- | (the \u201CBMP\u201D). These parsers can be convenient because of the good support\n-- | that PureScript has for writing `Char` literals like `'\u3042'`, `'\u03B2'`, `'C'`.\n-- |\n-- | The other primitive parsers, which return `CodePoint` and `String` types,\n-- | can parse the full Unicode character set. All of the primitive parsers\n-- | in this module can be used together.\n-- |\n-- | ### Position\n-- |\n-- | In a `String` parser, the `Position {index}` counts the number of\n-- | unicode `CodePoint`s since the beginning of the input string.\n-- |\n-- | Each tab character (`0x09`) encountered in a `String` parser will advance\n-- | the `Position {column}` by 8.\n-- |\n-- | These patterns will advance the `Position {line}` by 1 and reset\n-- | the `Position {column}` to 1:\n-- | - newline (`0x0A`)\n-- | - carriage-return (`0x0D`)\n-- | - carriage-return-newline (`0x0D 0x0A`)\nmodule Parsing.String\n  ( char\n  , string\n  , anyChar\n  , anyCodePoint\n  , satisfy\n  , satisfyCodePoint\n  , takeN\n  , rest\n  , eof\n  , match\n  , regex\n  , anyTill\n  , consumeWith\n  , parseErrorHuman\n  ) where\n\nimport Prelude hiding (between)\n\nimport Control.Monad.Rec.Class (Step(..), tailRecM)\nimport Data.Array (replicate)\nimport Data.Array.NonEmpty as NonEmptyArray\nimport Data.Either (Either(..))\nimport Data.Enum (fromEnum, toEnum)\nimport Data.Function.Uncurried (mkFn5, runFn2)\nimport Data.Int (odd)\nimport Data.Maybe (Maybe(..), fromJust)\nimport Data.String (CodePoint, Pattern(..), codePointAt, length, null, splitAt, stripPrefix, uncons)\nimport Data.String as CodePoint\nimport Data.String as String\nimport Data.String.CodeUnits as SCU\nimport Data.String.Regex as Regex\nimport Data.String.Regex.Flags (RegexFlags)\nimport Data.Tuple (Tuple(..))\nimport Parsing (ParseError(..), ParseState(..), ParserT(..), Position(..), getParserT)\nimport Parsing.Combinators (alt, try, (<?>))\nimport Partial.Unsafe (unsafePartial)\n\n-- | Match \u201Cend-of-file,\u201D the end of the input stream.\neof :: forall m. ParserT String m Unit\neof = ParserT\n  ( mkFn5 \\state1@(ParseState input pos _) _ _ throw done ->\n      if null input then\n        -- We must consume so this combines correctly with notFollowedBy\n        runFn2 done (ParseState input pos true) unit\n      else\n        runFn2 throw state1 (ParseError \"Expected EOF\" pos)\n  )\n\n-- | Match the entire rest of the input stream. Always succeeds.\nrest :: forall m. ParserT String m String\nrest = consumeWith \\consumed ->\n  Right { value: consumed, consumed, remainder: \"\" }\n\n-- | Match the specified string.\nstring :: forall m. String -> ParserT String m String\nstring str = consumeWith \\input ->\n  case stripPrefix (Pattern str) input of\n    Just remainder ->\n      Right { value: str, consumed: str, remainder }\n    _ ->\n      Left $ \"Expected \" <> show str\n\n-- | Match any BMP `Char`.\n-- | Parser will fail if the character is not in the Basic Multilingual Plane.\nanyChar :: forall m. ParserT String m Char\nanyChar = satisfy (const true)\n\n-- | Match any Unicode character.\n-- | Always succeeds when any input remains.\nanyCodePoint :: forall m. ParserT String m CodePoint\nanyCodePoint = satisfyCodePoint (const true)\n\n-- | Match a BMP `Char` satisfying the predicate.\nsatisfy :: forall m. (Char -> Boolean) -> ParserT String m Char\nsatisfy f = ParserT\n  ( mkFn5 \\state1@(ParseState input pos _) _ _ throw done ->\n      case uncons input of\n        Nothing ->\n          runFn2 throw state1 (ParseError \"Unexpected EOF\" pos)\n        Just { head, tail } -> do\n          let cp = fromEnum head\n          -- the `fromEnum` function doesn't check if this is beyond the\n          -- BMP, so we check that ourselves.\n          -- https://github.com/purescript/purescript-strings/issues/153\n          if cp < 0 || cp > 65535 then\n            runFn2 throw state1 (ParseError \"Expected Char\" pos)\n          else do\n            let ch = unsafePartial (fromJust (toEnum cp))\n            if f ch then\n              runFn2 done (ParseState tail (updatePosSingle pos head tail) true) ch\n            else\n              runFn2 throw state1 (ParseError \"Predicate unsatisfied\" pos)\n  )\n\n-- | Match a Unicode character satisfying the predicate.\nsatisfyCodePoint :: forall m. (CodePoint -> Boolean) -> ParserT String m CodePoint\nsatisfyCodePoint f = ParserT\n  ( mkFn5 \\state1@(ParseState input pos _) _ _ throw done ->\n      case uncons input of\n        Nothing ->\n          runFn2 throw state1 (ParseError \"Unexpected EOF\" pos)\n        Just { head, tail } ->\n          if f head then\n            runFn2 done (ParseState tail (updatePosSingle pos head tail) true) head\n          else\n            runFn2 throw state1 (ParseError \"Predicate unsatisfied\" pos)\n  )\n\n-- | Match the specified BMP `Char`.\nchar :: forall m. Char -> ParserT String m Char\nchar c = satisfy (_ == c) <?> show c\n\n-- | Match a `String` exactly *N* characters long.\ntakeN :: forall m. Int -> ParserT String m String\ntakeN n = consumeWith \\input -> do\n  let { before, after } = splitAt n input\n  if length before == n then\n    Right { value: before, consumed: before, remainder: after }\n  else\n    Left $ \"Could not take \" <> show n <> \" characters\"\n\n-- | Updates a `Position` by adding the columns and lines in `String`.\nupdatePosString :: Position -> String -> String -> Position\nupdatePosString pos before after = case uncons before of\n  Nothing -> pos\n  Just { head, tail } -> do\n    let\n      newPos\n        | String.null tail = updatePosSingle pos head after\n        | otherwise = updatePosSingle pos head tail\n    updatePosString newPos tail after\n\n-- | Updates a `Position` by adding the columns and lines in a\n-- | single `CodePoint`.\nupdatePosSingle :: Position -> CodePoint -> String -> Position\nupdatePosSingle (Position { index, line, column }) cp after = case fromEnum cp of\n  10 -> Position { index: index + 1, line: line + 1, column: 1 } -- \"\\n\"\n  13 ->\n    case codePointAt 0 after of\n      Just nextCp | fromEnum nextCp == 10 -> Position { index: index + 1, line, column } -- \"\\r\\n\" lookahead\n      _ -> Position { index: index + 1, line: line + 1, column: 1 } -- \"\\r\"\n  9 -> Position { index: index + 1, line, column: column + 8 - ((column - 1) `mod` 8) } -- \"\\t\" Who says that one tab is 8 columns?\n  _ -> Position { index: index + 1, line, column: column + 1 }\n\n-- | Combinator which returns both the result of a parse and the slice of\n-- | the input that was consumed while it was being parsed.\nmatch :: forall m a. ParserT String m a -> ParserT String m (Tuple String a)\nmatch p = do\n  ParseState input1 _ _ <- getParserT\n  x <- p\n  ParseState input2 _ _ <- getParserT\n  -- We use the `SCU.length`, which is in units of \u201Ccode units\u201D\n  -- instead of `Data.String.length`. which is in units of \u201Ccode points\u201D.\n  -- This is more efficient, and it will be correct as long as we can assume\n  -- the invariant that the `ParseState input` always begins on a code point\n  -- boundary.\n  pure $ Tuple (SCU.take (SCU.length input1 - SCU.length input2) input1) x\n\n-- | Compile a regular expression `String` into a regular expression parser.\n-- |\n-- | This function will use the `Data.String.Regex.regex` function to compile\n-- | and return a parser which can be used\n-- | in a `ParserT String m` monad.\n-- | If compilation fails then this function will return `Left` a compilation\n-- | error message.\n-- |\n-- | The returned parser will try to match the regular expression pattern once,\n-- | starting at the current parser position. On success, it will return\n-- | the matched substring.\n-- |\n-- | If the RegExp `String` is constant then we can assume that compilation will\n-- | always succeed and `unsafeCrashWith` if it doesn\u2019t. If we dynamically\n-- | generate the RegExp `String` at runtime then we should handle the\n-- | case where compilation of the RegExp fails.\n-- |\n-- | This function should be called outside the context of a `ParserT String m`\n-- | monad for two reasons:\n-- | 1. If we call this function inside of the `ParserT String m` monad and\n-- |    then `fail` the parse when the compilation fails,\n-- |    then that could be confusing because a parser failure is supposed to\n-- |    indicate an invalid input string.\n-- |    If the compilation failure occurs in an `alt` then the compilation\n-- |    failure might not be reported at all and instead\n-- |    the input string would be parsed incorrectly.\n-- | 2. Compiling a RegExp is expensive and it\u2019s better to do it\n-- |    once in advance and then use the compiled RegExp many times than\n-- |    to compile the RegExp many times during the parse.\n-- |\n-- | This parser may be useful for quickly consuming a large section of the\n-- | input `String`, because in a JavaScript runtime environment a compiled\n-- | RegExp is a lot faster than a monadic parser built from parsing primitives.\n-- |\n-- | [*MDN Regular Expressions Cheatsheet*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet)\n-- |\n-- | #### Example\n-- |\n-- | This example shows how to compile and run the `xMany` parser which will\n-- | capture the regular expression pattern `x*`.\n-- |\n-- | ```purescript\n-- | case regex \"x*\" noFlags of\n-- |   Left compileError -> unsafeCrashWith $ \"xMany failed to compile: \" <> compileError\n-- |   Right xMany -> runParser \"xxxZ\" do\n-- |     xMany\n-- | ```\n-- |\n-- | #### Flags\n-- |\n-- | Set `RegexFlags` with the `Semigroup` instance like this.\n-- |\n-- | ```purescript\n-- | regex \"x*\" (dotAll <> ignoreCase)\n-- | ```\n-- |\n-- | The `dotAll`, `unicode`, and `ignoreCase` flags might make sense for\n-- | a `regex` parser. The other flags will\n-- | probably cause surprising behavior and you should avoid them.\n-- |\n-- | [*MDN Advanced searching with flags*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags)\nregex :: forall m. String -> RegexFlags -> Either String (ParserT String m String)\nregex pattern flags =\n  Regex.regex (\"^(\" <> pattern <> \")\") flags <#> \\regexobj ->\n    consumeWith \\input -> do\n      case NonEmptyArray.head <$> Regex.match regexobj input of\n        Just (Just consumed) -> do\n          let remainder = SCU.drop (SCU.length consumed) input\n          Right { value: consumed, consumed, remainder }\n        _ ->\n          Left \"No Regex pattern match\"\n\n-- | Consume a portion of the input string while yielding a value.\n-- |\n-- | Takes a consumption function which takes the remaining input `String`\n-- | as its argument and returns either an error message, or three fields:\n-- |\n-- | * `value` is the value to return.\n-- | * `consumed` is the input `String` that was consumed. It is used to update the parser position.\n-- |   If the `consumed` `String` is non-empty then the `consumed` flag will\n-- |   be set to true. (Confusing terminology.)\n-- | * `remainder` is the new remaining input `String`.\n-- |\n-- | This function is used internally to construct primitive `String` parsers.\nconsumeWith\n  :: forall m a\n   . (String -> Either String { value :: a, consumed :: String, remainder :: String })\n  -> ParserT String m a\nconsumeWith f = ParserT\n  ( mkFn5 \\state1@(ParseState input pos _) _ _ throw done ->\n      case f input of\n        Left err ->\n          runFn2 throw state1 (ParseError err pos)\n        Right { value, consumed, remainder } ->\n          runFn2 done (ParseState remainder (updatePosString pos consumed remainder) (not (String.null consumed))) value\n  )\n\n-- | Combinator which finds the first position in the input `String` where the\n-- | phrase can parse. Returns both the\n-- | parsed result and the unparsable input section searched before the parse.\n-- | Will fail if no section of the input is parseable. To backtrack the input\n-- | stream on failure, combine with `tryRethrow`.\n-- |\n-- | This combinator works like\n-- | [Data.String.takeWhile](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:takeWhile)\n-- | or\n-- | [Data.String.Regex.search](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:search)\n-- | and it allows using a parser for the pattern search.\n-- |\n-- | This combinator is equivalent to `manyTill_ anyCodePoint`, but it will be\n-- | faster because it returns a slice of the input `String` for the\n-- | section preceding the parse instead of a `List CodePoint`.\n-- |\n-- | Be careful not to look too far\n-- | ahead; if the phrase parser looks to the end of the input then `anyTill`\n-- | could be *O(n\u00B2)*.\nanyTill\n  :: forall m a\n   . Monad m\n  => ParserT String m a\n  -> ParserT String m (Tuple String a)\nanyTill p = do\n  ParseState input1 _ _ <- getParserT\n  Tuple input2 t <- tailRecM go unit\n  pure $ Tuple (SCU.take (SCU.length input1 - SCU.length input2) input1) t\n  where\n  go unit = alt\n    ( do\n        ParseState input2 _ _ <- getParserT\n        t <- try p\n        pure $ Done $ Tuple input2 t\n    )\n    ( do\n        _ <- anyCodePoint\n        pure $ Loop unit\n    )\n\n-- | Returns three `String`s which, when printed line-by-line, will show\n-- | a human-readable parsing error message with context.\n-- |\n-- | #### Input arguments\n-- |\n-- | * The first argument is the input `String` given to the parser which\n-- | errored.\n-- | * The second argument is a positive `Int` which indicates how many\n-- | characters of input `String` context are wanted around the parsing error.\n-- | * The third argument is the `ParseError` for the input `String`.\n-- |\n-- | #### Output `String`s\n-- |\n-- | 1. The parse error message and the parsing position.\n-- | 2. A string with an arrow that points to the error position in the\n-- |    input context (in a fixed-width font).\n-- | 3. The input context. A substring of the input which tries to center\n-- |    the error position and have the wanted length and not include\n-- |    any newlines or carriage returns.\n-- |\n-- |    If the parse error occurred on a carriage return or newline character,\n-- |    then that character will be included at the end of the input context.\n-- |\n-- | #### Example\n-- |\n-- | ```\n-- | let input = \"12345six789\"\n-- | case runParser input (replicateA 9 String.Basic.digit) of\n-- |   Left err ->\n-- |     log $ String.joinWith \"\\n\" $ parseErrorHuman input 20 err\n-- | ```\n-- | ---\n-- | ```\n-- | Expected digit at position index:5 (line:1, column:6)\n-- |      \u25BC\n-- | 12345six789\n-- | ```\nparseErrorHuman :: String -> Int -> ParseError -> Array String\nparseErrorHuman input contextSize (ParseError msg (Position { line, column, index })) =\n  -- inspired by\n  -- https://github.com/elm/parser/blob/master/README.md#tracking-context\n  [ msg <> \" at position index:\" <> show index\n      <> \" (line:\"\n      <> show line\n      <> \", column:\"\n      <> show column\n      <> \")\"\n  , (String.joinWith \"\" (replicate (lineIndex - minPosBefore) \" \")) <> \"\u25BC\" -- best way to construct string of spaces?\n  , inputContext\n  ]\n  where\n  -- select the input line in which the error appears\n  -- sadly we can't use splitCap because of circular module dependency and we\n  -- don't feel like separating out an \u201CInternal\u201D module.\n  { posBegin, posEnd, lineBegin } = go 0 input 0 input\n    where\n    go posBegin lineBegin posEnd lineEnd =\n      case String.uncons lineEnd of\n        Just { head, tail } | head == CodePoint.codePointFromChar '\\n' ->\n          if posEnd == index -- uh-oh, error at the newline\n          -- so include the newline at the end of the selected line.\n          then { posBegin, posEnd: posEnd + 1, lineBegin }\n          else if posEnd > index then { posBegin, posEnd, lineBegin }\n          else go (posEnd + 1) tail (posEnd + 1) tail\n        Just { head, tail } | head == CodePoint.codePointFromChar '\\r' ->\n          if posEnd == index -- uh-oh, error at the carriage return\n          -- so include the carriage return at the end of the selected line.\n          -- we don't need to add the possible following newline because\n          -- we're not printing a line break here, we're just making sure\n          -- to include the character at the position which errored.\n          then { posBegin, posEnd: posEnd + 1, lineBegin }\n          else if posEnd > index then { posBegin, posEnd, lineBegin }\n          else go (posEnd + 1) tail (posEnd + 1) tail\n        Just { tail } -> go posBegin lineBegin (posEnd + 1) tail\n        _ -> { posBegin, posEnd, lineBegin }\n  lineSelect = String.take (posEnd - posBegin) lineBegin\n  lineIndex = index - posBegin\n  lineLength = String.length lineSelect\n\n  -- position minus half of context\n  bestPosBefore = lineIndex - (contextSize / 2)\n  -- position plus half of context\n  bestPosAfter = lineIndex + (contextSize / 2) + if odd contextSize then 1 else 0\n\n  -- constrain the context window to selected line\n  -- grow the context window to contextSize if the error is at beginning or end of selected line\n  Tuple minPosBefore maxPosAfter =\n    if bestPosBefore >= 0 then\n      if bestPosAfter <= lineLength then Tuple bestPosBefore bestPosAfter\n      else Tuple (max 0 (lineLength - contextSize)) lineLength\n    else Tuple 0 (min lineLength contextSize)\n\n  inputContext = String.take (maxPosAfter - minPosBefore) $ String.drop minPosBefore lineSelect\n", "-- | Basic `String` parsers derived from primitive `String` parsers.\n-- |\n-- | #### unicode dependency\n-- |\n-- | Some of the parsers in this module depend on the\n-- | [__unicode__](https://pursuit.purescript.org/packages/purescript-unicode)\n-- | package.\n-- | The __unicode__ package is large; about half a megabyte unminified.\n-- | If code which depends on __parsing__ is \u201Ctree-shaken\u201D\n-- | \u201Cdead-code-eliminated,\u201D then\n-- | all of the __unicode__ package will be eliminated.\n-- |\n-- | The __unicode__-dependent parsers in this module will call functions\n-- | which use large lookup tables from the __unicode__ package.\n-- | Using any of these __unicode__-dependent parsers\n-- | may result in a minified, dead-code-eliminated bundle size increase\n-- | of over 100 kilobytes.\nmodule Parsing.String.Basic\n  ( digit\n  , hexDigit\n  , octDigit\n  , letter\n  , space\n  , lower\n  , upper\n  , alphaNum\n  , intDecimal\n  , number\n  , takeWhile\n  , takeWhile1\n  , whiteSpace\n  , skipSpaces\n  , oneOf\n  , oneOfCodePoints\n  , noneOf\n  , noneOfCodePoints\n  ) where\n\nimport Prelude\n\nimport Data.Array (elem, notElem)\nimport Data.CodePoint.Unicode (isAlpha, isAlphaNum, isDecDigit, isHexDigit, isLower, isOctDigit, isSpace, isUpper)\nimport Data.Either (Either(..), either)\nimport Data.Int as Data.Int\nimport Data.Maybe (Maybe(..))\nimport Data.Number (infinity, nan)\nimport Data.Number as Data.Number\nimport Data.String (CodePoint, singleton)\nimport Data.String as String\nimport Data.String.CodePoints (codePointFromChar)\nimport Data.String.CodeUnits as SCU\nimport Parsing (ParserT, fail)\nimport Parsing.Combinators (choice, tryRethrow, (<?>), (<|>), (<~?>))\nimport Parsing.String (consumeWith, regex, satisfy, satisfyCodePoint, string)\nimport Partial.Unsafe (unsafeCrashWith)\n\n-- | Parse a digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isDecDigit`.\ndigit :: forall m. ParserT String m Char\ndigit = satisfyCP isDecDigit <?> \"digit\"\n\n-- | Parse a hex digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isHexDigit`.\nhexDigit :: forall m. ParserT String m Char\nhexDigit = satisfyCP isHexDigit <?> \"hex digit\"\n\n-- | Parse an octal digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isOctDigit`.\noctDigit :: forall m. ParserT String m Char\noctDigit = satisfyCP isOctDigit <?> \"oct digit\"\n\n-- | Parse a lowercase letter.  Matches any char that satisfies `Data.CodePoint.Unicode.isLower`.\nlower :: forall m. ParserT String m Char\nlower = satisfyCP isLower <?> \"lowercase letter\"\n\n-- | Parse an uppercase letter.  Matches any char that satisfies `Data.CodePoint.Unicode.isUpper`.\nupper :: forall m. ParserT String m Char\nupper = satisfyCP isUpper <?> \"uppercase letter\"\n\n-- | Parse a space character.  Matches any char that satisfies `Data.CodePoint.Unicode.isSpace`.\nspace :: forall m. ParserT String m Char\nspace = satisfyCP isSpace <?> \"space\"\n\n-- | Parse an alphabetical character.  Matches any char that satisfies `Data.CodePoint.Unicode.isAlpha`.\nletter :: forall m. ParserT String m Char\nletter = satisfyCP isAlpha <?> \"letter\"\n\n-- | Parse an alphabetical or numerical character.\n-- | Matches any char that satisfies `Data.CodePoint.Unicode.isAlphaNum`.\nalphaNum :: forall m. ParserT String m Char\nalphaNum = satisfyCP isAlphaNum <?> \"letter or digit\"\n\n-- | Parser based on the __Data.Number.fromString__ function.\n-- |\n-- | This should be the inverse of `show :: Number -> String`.\n-- |\n-- | Examples of strings which can be parsed by this parser:\n-- | * `\"3\"`\n-- | * `\"3.0\"`\n-- | * `\".3\"`\n-- | * `\"-0.3\"`\n-- | * `\"+0.3\"`\n-- | * `\"-3e-1\"`\n-- | * `\"-3.0E-1.0\"`\n-- | * `\"NaN\"`\n-- | * `\"-Infinity\"`\nnumber :: forall m. ParserT String m Number\nnumber =\n  choice\n    [ string \"Infinity\" *> pure infinity\n    , string \"+Infinity\" *> pure infinity\n    , string \"-Infinity\" *> pure (negate infinity)\n    , string \"NaN\" *> pure nan\n    , tryRethrow $ do\n        -- This primitiv-ish parser should always backtrack on fail.\n        -- Currently regex allows some illegal inputs, like \".\"\n        -- The important thing is that the regex will find the correct\n        -- boundary of a candidate string to pass to fromString.\n        section <- numberRegex\n        -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat\n        case Data.Number.fromString section of\n          Nothing -> fail \"Expected Number\"\n          Just x -> pure x\n    ] <|> fail \"Expected Number\"\n\n-- Non-exported regex is compiled at startup time.\nnumberRegex :: forall m. ParserT String m String\nnumberRegex = either unsafeCrashWith identity $ regex pattern mempty\n  where\n  pattern = \"[+-]?[0-9]*(\\\\.[0-9]*)?([eE][+-]?[0-9]*(\\\\.[0-9]*)?)?\"\n\n-- | Parser based on the __Data.Int.fromString__ function.\n-- |\n-- | This should be the inverse of `show :: Int -> String`.\n-- |\n-- | Examples of strings which can be parsed by this parser:\n-- | * `\"3\"`\n-- | * `\"-3\"`\n-- | * `\"+300\"`\nintDecimal :: forall m. ParserT String m Int\nintDecimal = tryRethrow do\n  section <- intDecimalRegex <|> fail \"Expected Int\"\n  case Data.Int.fromString section of\n    Nothing -> fail \"Expected Int\"\n    Just x -> pure x\n\n-- Non-exported regex is compiled at startup time.\nintDecimalRegex :: forall m. ParserT String m String\nintDecimalRegex = either unsafeCrashWith identity $ regex pattern mempty\n  where\n  pattern = \"[+-]?[0-9]+\"\n\n-- | Helper function\nsatisfyCP :: forall m. (CodePoint -> Boolean) -> ParserT String m Char\nsatisfyCP p = satisfy (p <<< codePointFromChar)\n\n-- | Match zero or more whitespace characters satisfying\n-- | `Data.CodePoint.Unicode.isSpace`.\n-- |\n-- | Always succeeds. Will consume only when matched whitespace string\n-- | is non-empty.\nwhiteSpace :: forall m. ParserT String m String\nwhiteSpace = takeWhile isSpace\n\n-- | Skip whitespace characters satisfying `Data.CodePoint.Unicode.isSpace`\n-- | and throw them away.\n-- |\n-- | Always succeeds. Will only consume when some characters are skipped.\nskipSpaces :: forall m. ParserT String m Unit\nskipSpaces = void whiteSpace\n\n-- | Match one of the BMP `Char`s in the array.\noneOf :: forall m. Array Char -> ParserT String m Char\noneOf ss = satisfy (flip elem ss) <~?> \\_ -> \"one of \" <> show ss\n\n-- | Match any BMP `Char` not in the array.\nnoneOf :: forall m. Array Char -> ParserT String m Char\nnoneOf ss = satisfy (flip notElem ss) <~?> \\_ -> \"none of \" <> show ss\n\n-- | Match one of the Unicode characters in the array.\noneOfCodePoints :: forall m. Array CodePoint -> ParserT String m CodePoint\noneOfCodePoints ss = satisfyCodePoint (flip elem ss) <~?> \\_ -> \"one of \" <> show (singleton <$> ss)\n\n-- | Match any Unicode character not in the array.\nnoneOfCodePoints :: forall m. Array CodePoint -> ParserT String m CodePoint\nnoneOfCodePoints ss = satisfyCodePoint (flip notElem ss) <~?> \\_ -> \"none of \" <> show (singleton <$> ss)\n\n-- | Take the longest `String` for which the characters satisfy the\n-- | predicate.\n-- |\n-- | See [__`Data.CodePoint.Unicode`__](https://pursuit.purescript.org/packages/purescript-unicode/docs/Data.CodePoint.Unicode)\n-- | for useful predicates.\n-- |\n-- | Example:\n-- |\n-- | ```\n-- | runParser \"Tackling the Awkward Squad\" do\n-- |   takeWhile Data.CodePoint.Unicode.isLetter\n-- | ```\n-- | ---\n-- | ```\n-- | Right \"Tackling\"\n-- | ```\n-- |\n-- | You should prefer `takeWhile isLetter` to\n-- | `fromCharArray <$> Data.Array.many letter`.\ntakeWhile :: forall m. (CodePoint -> Boolean) -> ParserT String m String\ntakeWhile predicate =\n  consumeWith \\s ->\n    let\n      value = String.takeWhile predicate s\n    in\n      Right\n        { consumed: value\n        , remainder: SCU.drop (SCU.length value) s\n        , value\n        }\n\n-- | Take the longest `String` for which the characters satisfy the\n-- | predicate. Require at least 1 character. You should supply an\n-- | expectation description for the error\n-- | message for when the predicate fails on the first character.\n-- |\n-- | See [__`Data.CodePoint.Unicode`__](https://pursuit.purescript.org/packages/purescript-unicode/docs/Data.CodePoint.Unicode)\n-- | for useful predicates.\n-- |\n-- | Example:\n-- |\n-- | ```\n-- | runParser \"Tackling the Awkward Squad\" do\n-- |   takeWhile1 Data.CodePoint.Unicode.isLetter <?> \"a letter\"\n-- | ```\n-- | ---\n-- | ```\n-- | Right \"Tackling\"\n-- | ```\ntakeWhile1 :: forall m. (CodePoint -> Boolean) -> ParserT String m String\ntakeWhile1 predicate =\n  consumeWith \\s ->\n    let\n      value = String.takeWhile predicate s\n      len = SCU.length value\n    in\n      if len > 0 then Right\n        { consumed: value\n        , remainder: SCU.drop (SCU.length value) s\n        , value\n        }\n      else Left \"Expected character satisfying predicate\"\n", "module Main (parse) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Data.Bifunctor (lmap)\nimport Data.Either (Either)\nimport Data.String as Str\nimport Parsing (Parser)\nimport Parsing as Parsing\nimport Parsing.Combinators ((<?>))\nimport Parsing.Combinators as Parsing.Combinators\nimport Parsing.String as Parsing.String\nimport Parsing.String.Basic as Parsing.String.Basic\n\n-- | INTERNAL\npTrueShorthand :: Parser String Boolean\npTrueShorthand =\n  Parsing.String.Basic.oneOf [ 't', 'y', '1' ]\n    *> Parsing.String.eof\n    *> pure true\n\n-- | INTERNAL\npFalseShorthand :: Parser String Boolean\npFalseShorthand =\n  Parsing.String.Basic.oneOf [ 'f', 'n', '0' ]\n    *> Parsing.String.eof\n    *> pure false\n\n-- | INTERNAL\npTrueLonghand :: Parser String Boolean\npTrueLonghand =\n  ( Parsing.String.string \"on\"\n      <|> Parsing.String.string \"true\"\n      <|> Parsing.String.string \"yes\"\n  )\n    *> Parsing.String.eof\n    *> pure true\n\n-- | INTERNAL\npFalseLonghand :: Parser String Boolean\npFalseLonghand =\n  ( Parsing.String.string \"off\"\n      <|> Parsing.String.string \"false\"\n      <|> Parsing.String.string \"no\"\n  )\n    *> Parsing.String.eof\n    *> pure false\n\n-- | INTERNAL\n-- |\n-- | A parser for Flatfile specific booleans.\nparser :: Parser String Boolean\nparser = do\n  Parsing.Combinators.try\n    ( pTrueLonghand\n        <|> pFalseLonghand\n        <|> pTrueShorthand\n        <|> pFalseShorthand\n    ) <?> \"one of [ 't', 'y', '1', 'f', 'n', '0', 'on', 'true', 'yes', 'off', 'false', 'no' ]\"\n\n-- | Parse a string as a possible boolean.\nparse :: String -> Either String Boolean\nparse = lmap Parsing.parseErrorMessage\n  <<< flip Parsing.runParser parser\n  <<< (Str.toLower <<< Str.trim)\n\n-- parse :: String -> {_tag :: \"left\" | \"right\", value :: Boolean} -- row record type?\n-- parse = do\n--   result <- flip Parsing.runParser parser <<< (Str.toLower <<< Str.trim)\n--   case result of\n--     Parsing.ParseError a -> Parsing.parseErrorMessage a\n--     a -> a\n"],
  "mappings": "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",
  "names": ["eq", "empty", "identity", "defer", "unsafeCoerce", "apply", "map", "pure", "top", "defer", "step", "map", "message", "defer", "lift", "Cons", "head", "tail", "foldr", "compare", "from", "sortByImpl", "compare", "from", "findIndex", "findIndex", "elem", "head", "tail", "apply", "map", "last", "Just", "Nothing", "unsafeCodePointAt0", "index", "length", "length", "drop", "splitAt", "splitAt", "length", "uncons", "length", "fromEnum", "fromEnum", "length", "uncons", "fromEnum", "mod", "uncons", "uncons", "fromEnum", "fromJust", "toEnum", "oneOf", "show1", "applySecond", "oneOf", "pure", "alt"]
}
